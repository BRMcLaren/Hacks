/*
 *  This file is auto generated by oeedger8r. DO NOT EDIT.
 */
#include "all_t.h"

#include <openenclave/edger8r/enclave.h>

#include <stdlib.h>
#include <string.h>
#include <wchar.h>

OE_EXTERNC_BEGIN

/**** ECALL functions. ****/

void ecall_configure(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    configure_args_t* pargs_in = (configure_args_t*)input_buffer;
    configure_args_t* pargs_out = (configure_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->enabled)
        OE_SET_OUT_POINTER(enabled, sizeof(uint8_t[4]), uint8_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    configure(
        *(uint8_t(*)[4])pargs_in->enabled);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_aliasing_a(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    aliasing_a_args_t* pargs_in = (aliasing_a_args_t*)input_buffer;
    aliasing_a_args_t* pargs_out = (aliasing_a_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->d)
        OE_SET_IN_POINTER(d, (pargs_in->c * sizeof(char)), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = aliasing_a(
        (const char*)pargs_in->d,
        pargs_in->c);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_aliasing_b(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    aliasing_b_args_t* pargs_in = (aliasing_b_args_t*)input_buffer;
    aliasing_b_args_t* pargs_out = (aliasing_b_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->g)
        OE_SET_IN_POINTER(g, (pargs_in->f * sizeof(size_t)), size_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->h)
        OE_SET_OUT_POINTER(h, (pargs_in->i * sizeof(char)), char*);
    if (pargs_in->j)
        OE_SET_OUT_POINTER(j, (1 * sizeof(size_t)), size_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = aliasing_b(
        pargs_in->e,
        pargs_in->g,
        pargs_in->f,
        pargs_in->h,
        pargs_in->i,
        pargs_in->j);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_aliasing_c(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    aliasing_c_args_t* pargs_in = (aliasing_c_args_t*)input_buffer;
    aliasing_c_args_t* pargs_out = (aliasing_c_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a)
        OE_SET_IN_POINTER(a, sizeof(char[2]), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = aliasing_c(
        *(char(*)[2])pargs_in->a);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_char(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_char_args_t* pargs_in = (ecall_array_char_args_t*)input_buffer;
    ecall_array_char_args_t* pargs_out = (ecall_array_char_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(char[2]), char*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(char[2][2]), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(char[2][2]), char*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(char[3][3]), char*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_char(
        *(char(*)[2])pargs_in->a1,
        *(char(*)[2][2])pargs_in->a2,
        *(char(*)[3][3])pargs_in->a3,
        *(char(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_wchar_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_wchar_t_args_t* pargs_in = (ecall_array_wchar_t_args_t*)input_buffer;
    ecall_array_wchar_t_args_t* pargs_out = (ecall_array_wchar_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(wchar_t[2]), wchar_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(wchar_t[2][2]), wchar_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(wchar_t[2][2]), wchar_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(wchar_t[3][3]), wchar_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_wchar_t(
        *(wchar_t(*)[2])pargs_in->a1,
        *(wchar_t(*)[2][2])pargs_in->a2,
        *(wchar_t(*)[3][3])pargs_in->a3,
        *(wchar_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_short(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_short_args_t* pargs_in = (ecall_array_short_args_t*)input_buffer;
    ecall_array_short_args_t* pargs_out = (ecall_array_short_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(short int[2]), short int*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(short int[2][2]), short int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(short int[2][2]), short int*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(short int[3][3]), short int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_short(
        *(short int(*)[2])pargs_in->a1,
        *(short int(*)[2][2])pargs_in->a2,
        *(short int(*)[3][3])pargs_in->a3,
        *(short int(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_int(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_int_args_t* pargs_in = (ecall_array_int_args_t*)input_buffer;
    ecall_array_int_args_t* pargs_out = (ecall_array_int_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(int[2]), int*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(int[2][2]), int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(int[2][2]), int*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(int[3][3]), int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_int(
        *(int(*)[2])pargs_in->a1,
        *(int(*)[2][2])pargs_in->a2,
        *(int(*)[3][3])pargs_in->a3,
        *(int(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_float(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_float_args_t* pargs_in = (ecall_array_float_args_t*)input_buffer;
    ecall_array_float_args_t* pargs_out = (ecall_array_float_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(float[2]), float*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(float[2][2]), float*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(float[2][2]), float*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(float[3][3]), float*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_float(
        *(float(*)[2])pargs_in->a1,
        *(float(*)[2][2])pargs_in->a2,
        *(float(*)[3][3])pargs_in->a3,
        *(float(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_double(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_double_args_t* pargs_in = (ecall_array_double_args_t*)input_buffer;
    ecall_array_double_args_t* pargs_out = (ecall_array_double_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(double[2]), double*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(double[2][2]), double*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(double[2][2]), double*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(double[3][3]), double*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_double(
        *(double(*)[2])pargs_in->a1,
        *(double(*)[2][2])pargs_in->a2,
        *(double(*)[3][3])pargs_in->a3,
        *(double(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_long_args_t* pargs_in = (ecall_array_long_args_t*)input_buffer;
    ecall_array_long_args_t* pargs_out = (ecall_array_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(long int[2]), long int*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(long int[2][2]), long int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(long int[2][2]), long int*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(long int[3][3]), long int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_long(
        *(long int(*)[2])pargs_in->a1,
        *(long int(*)[2][2])pargs_in->a2,
        *(long int(*)[3][3])pargs_in->a3,
        *(long int(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_size_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_size_t_args_t* pargs_in = (ecall_array_size_t_args_t*)input_buffer;
    ecall_array_size_t_args_t* pargs_out = (ecall_array_size_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(size_t[2]), size_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(size_t[2][2]), size_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(size_t[2][2]), size_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(size_t[3][3]), size_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_size_t(
        *(size_t(*)[2])pargs_in->a1,
        *(size_t(*)[2][2])pargs_in->a2,
        *(size_t(*)[3][3])pargs_in->a3,
        *(size_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_unsigned(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_unsigned_args_t* pargs_in = (ecall_array_unsigned_args_t*)input_buffer;
    ecall_array_unsigned_args_t* pargs_out = (ecall_array_unsigned_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(unsigned int[2]), unsigned int*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(unsigned int[2][2]), unsigned int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(unsigned int[2][2]), unsigned int*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(unsigned int[3][3]), unsigned int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_unsigned(
        *(unsigned int(*)[2])pargs_in->a1,
        *(unsigned int(*)[2][2])pargs_in->a2,
        *(unsigned int(*)[3][3])pargs_in->a3,
        *(unsigned int(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_int8_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_int8_t_args_t* pargs_in = (ecall_array_int8_t_args_t*)input_buffer;
    ecall_array_int8_t_args_t* pargs_out = (ecall_array_int8_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(int8_t[2]), int8_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(int8_t[2][2]), int8_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(int8_t[2][2]), int8_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(int8_t[3][3]), int8_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_int8_t(
        *(int8_t(*)[2])pargs_in->a1,
        *(int8_t(*)[2][2])pargs_in->a2,
        *(int8_t(*)[3][3])pargs_in->a3,
        *(int8_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_int16_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_int16_t_args_t* pargs_in = (ecall_array_int16_t_args_t*)input_buffer;
    ecall_array_int16_t_args_t* pargs_out = (ecall_array_int16_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(int16_t[2]), int16_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(int16_t[2][2]), int16_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(int16_t[2][2]), int16_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(int16_t[3][3]), int16_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_int16_t(
        *(int16_t(*)[2])pargs_in->a1,
        *(int16_t(*)[2][2])pargs_in->a2,
        *(int16_t(*)[3][3])pargs_in->a3,
        *(int16_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_int32_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_int32_t_args_t* pargs_in = (ecall_array_int32_t_args_t*)input_buffer;
    ecall_array_int32_t_args_t* pargs_out = (ecall_array_int32_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(int32_t[2]), int32_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(int32_t[2][2]), int32_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(int32_t[2][2]), int32_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(int32_t[3][3]), int32_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_int32_t(
        *(int32_t(*)[2])pargs_in->a1,
        *(int32_t(*)[2][2])pargs_in->a2,
        *(int32_t(*)[3][3])pargs_in->a3,
        *(int32_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_int64_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_int64_t_args_t* pargs_in = (ecall_array_int64_t_args_t*)input_buffer;
    ecall_array_int64_t_args_t* pargs_out = (ecall_array_int64_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(int64_t[2]), int64_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(int64_t[2][2]), int64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(int64_t[2][2]), int64_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(int64_t[3][3]), int64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_int64_t(
        *(int64_t(*)[2])pargs_in->a1,
        *(int64_t(*)[2][2])pargs_in->a2,
        *(int64_t(*)[3][3])pargs_in->a3,
        *(int64_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_uint8_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_uint8_t_args_t* pargs_in = (ecall_array_uint8_t_args_t*)input_buffer;
    ecall_array_uint8_t_args_t* pargs_out = (ecall_array_uint8_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(uint8_t[2]), uint8_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(uint8_t[2][2]), uint8_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(uint8_t[2][2]), uint8_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(uint8_t[3][3]), uint8_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_uint8_t(
        *(uint8_t(*)[2])pargs_in->a1,
        *(uint8_t(*)[2][2])pargs_in->a2,
        *(uint8_t(*)[3][3])pargs_in->a3,
        *(uint8_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_uint16_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_uint16_t_args_t* pargs_in = (ecall_array_uint16_t_args_t*)input_buffer;
    ecall_array_uint16_t_args_t* pargs_out = (ecall_array_uint16_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(uint16_t[2]), uint16_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(uint16_t[2][2]), uint16_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(uint16_t[2][2]), uint16_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(uint16_t[3][3]), uint16_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_uint16_t(
        *(uint16_t(*)[2])pargs_in->a1,
        *(uint16_t(*)[2][2])pargs_in->a2,
        *(uint16_t(*)[3][3])pargs_in->a3,
        *(uint16_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_uint32_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_uint32_t_args_t* pargs_in = (ecall_array_uint32_t_args_t*)input_buffer;
    ecall_array_uint32_t_args_t* pargs_out = (ecall_array_uint32_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(uint32_t[2]), uint32_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(uint32_t[2][2]), uint32_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(uint32_t[2][2]), uint32_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(uint32_t[3][3]), uint32_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_uint32_t(
        *(uint32_t(*)[2])pargs_in->a1,
        *(uint32_t(*)[2][2])pargs_in->a2,
        *(uint32_t(*)[3][3])pargs_in->a3,
        *(uint32_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_uint64_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_uint64_t_args_t* pargs_in = (ecall_array_uint64_t_args_t*)input_buffer;
    ecall_array_uint64_t_args_t* pargs_out = (ecall_array_uint64_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(uint64_t[2]), uint64_t*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(uint64_t[2][2]), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(uint64_t[2][2]), uint64_t*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(uint64_t[3][3]), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_uint64_t(
        *(uint64_t(*)[2])pargs_in->a1,
        *(uint64_t(*)[2][2])pargs_in->a2,
        *(uint64_t(*)[3][3])pargs_in->a3,
        *(uint64_t(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_long_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_long_long_args_t* pargs_in = (ecall_array_long_long_args_t*)input_buffer;
    ecall_array_long_long_args_t* pargs_out = (ecall_array_long_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(long long[2]), long long*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(long long[2][2]), long long*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(long long[2][2]), long long*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(long long[3][3]), long long*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_long_long(
        *(long long(*)[2])pargs_in->a1,
        *(long long(*)[2][2])pargs_in->a2,
        *(long long(*)[3][3])pargs_in->a3,
        *(long long(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_long_double(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_long_double_args_t* pargs_in = (ecall_array_long_double_args_t*)input_buffer;
    ecall_array_long_double_args_t* pargs_out = (ecall_array_long_double_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(long double[2]), long double*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(long double[2][2]), long double*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(long double[2][2]), long double*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(long double[3][3]), long double*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_long_double(
        *(long double(*)[2])pargs_in->a1,
        *(long double(*)[2][2])pargs_in->a2,
        *(long double(*)[3][3])pargs_in->a3,
        *(long double(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_unsigned_char(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_unsigned_char_args_t* pargs_in = (ecall_array_unsigned_char_args_t*)input_buffer;
    ecall_array_unsigned_char_args_t* pargs_out = (ecall_array_unsigned_char_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(unsigned char[2]), unsigned char*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(unsigned char[2][2]), unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(unsigned char[2][2]), unsigned char*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(unsigned char[3][3]), unsigned char*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_unsigned_char(
        *(unsigned char(*)[2])pargs_in->a1,
        *(unsigned char(*)[2][2])pargs_in->a2,
        *(unsigned char(*)[3][3])pargs_in->a3,
        *(unsigned char(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_unsigned_short(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_unsigned_short_args_t* pargs_in = (ecall_array_unsigned_short_args_t*)input_buffer;
    ecall_array_unsigned_short_args_t* pargs_out = (ecall_array_unsigned_short_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(unsigned short int[2]), unsigned short int*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(unsigned short int[2][2]), unsigned short int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(unsigned short int[2][2]), unsigned short int*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(unsigned short int[3][3]), unsigned short int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_unsigned_short(
        *(unsigned short int(*)[2])pargs_in->a1,
        *(unsigned short int(*)[2][2])pargs_in->a2,
        *(unsigned short int(*)[3][3])pargs_in->a3,
        *(unsigned short int(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_unsigned_int(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_unsigned_int_args_t* pargs_in = (ecall_array_unsigned_int_args_t*)input_buffer;
    ecall_array_unsigned_int_args_t* pargs_out = (ecall_array_unsigned_int_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(unsigned int[2]), unsigned int*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(unsigned int[2][2]), unsigned int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(unsigned int[2][2]), unsigned int*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(unsigned int[3][3]), unsigned int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_unsigned_int(
        *(unsigned int(*)[2])pargs_in->a1,
        *(unsigned int(*)[2][2])pargs_in->a2,
        *(unsigned int(*)[3][3])pargs_in->a3,
        *(unsigned int(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_unsigned_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_unsigned_long_args_t* pargs_in = (ecall_array_unsigned_long_args_t*)input_buffer;
    ecall_array_unsigned_long_args_t* pargs_out = (ecall_array_unsigned_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(unsigned long int[2]), unsigned long int*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(unsigned long int[2][2]), unsigned long int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(unsigned long int[2][2]), unsigned long int*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(unsigned long int[3][3]), unsigned long int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_unsigned_long(
        *(unsigned long int(*)[2])pargs_in->a1,
        *(unsigned long int(*)[2][2])pargs_in->a2,
        *(unsigned long int(*)[3][3])pargs_in->a3,
        *(unsigned long int(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_unsigned_long_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_unsigned_long_long_args_t* pargs_in = (ecall_array_unsigned_long_long_args_t*)input_buffer;
    ecall_array_unsigned_long_long_args_t* pargs_out = (ecall_array_unsigned_long_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(unsigned long long[2]), unsigned long long*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(unsigned long long[2][2]), unsigned long long*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(unsigned long long[2][2]), unsigned long long*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(unsigned long long[3][3]), unsigned long long*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_unsigned_long_long(
        *(unsigned long long(*)[2])pargs_in->a1,
        *(unsigned long long(*)[2][2])pargs_in->a2,
        *(unsigned long long(*)[3][3])pargs_in->a3,
        *(unsigned long long(*)[4][4])pargs_in->a4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_array_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_array_edl_ocalls_args_t* pargs_in = (test_array_edl_ocalls_args_t*)input_buffer;
    test_array_edl_ocalls_args_t* pargs_out = (test_array_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_array_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_array_assert_all_called(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_array_assert_all_called_args_t* pargs_in = (ecall_array_assert_all_called_args_t*)input_buffer;
    ecall_array_assert_all_called_args_t* pargs_out = (ecall_array_assert_all_called_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_array_assert_all_called(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_basic_types(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_basic_types_args_t* pargs_in = (ecall_basic_types_args_t*)input_buffer;
    ecall_basic_types_args_t* pargs_out = (ecall_basic_types_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_basic_types(
        pargs_in->arg1,
        pargs_in->arg2,
        pargs_in->arg3,
        pargs_in->arg4,
        pargs_in->arg5,
        pargs_in->arg6,
        pargs_in->arg7,
        pargs_in->arg8,
        pargs_in->arg9,
        pargs_in->arg10,
        pargs_in->arg11,
        pargs_in->arg12,
        pargs_in->arg13,
        pargs_in->arg14,
        pargs_in->arg15,
        pargs_in->arg16,
        pargs_in->arg17,
        pargs_in->arg18,
        pargs_in->arg19,
        pargs_in->arg20);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_basic_non_portable_types(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_basic_non_portable_types_args_t* pargs_in = (ecall_basic_non_portable_types_args_t*)input_buffer;
    ecall_basic_non_portable_types_args_t* pargs_out = (ecall_basic_non_portable_types_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_basic_non_portable_types(
        pargs_in->arg1,
        pargs_in->arg2,
        pargs_in->arg3,
        pargs_in->arg4);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_get_enclave_sizeof(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    get_enclave_sizeof_args_t* pargs_in = (get_enclave_sizeof_args_t*)input_buffer;
    get_enclave_sizeof_args_t* pargs_out = (get_enclave_sizeof_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = get_enclave_sizeof(
        pargs_in->t);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_char(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_char_args_t* pargs_in = (ecall_ret_char_args_t*)input_buffer;
    ecall_ret_char_args_t* pargs_out = (ecall_ret_char_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_char(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_wchar_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_wchar_t_args_t* pargs_in = (ecall_ret_wchar_t_args_t*)input_buffer;
    ecall_ret_wchar_t_args_t* pargs_out = (ecall_ret_wchar_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_wchar_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_short(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_short_args_t* pargs_in = (ecall_ret_short_args_t*)input_buffer;
    ecall_ret_short_args_t* pargs_out = (ecall_ret_short_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_short(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_int(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_int_args_t* pargs_in = (ecall_ret_int_args_t*)input_buffer;
    ecall_ret_int_args_t* pargs_out = (ecall_ret_int_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_int(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_float(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_float_args_t* pargs_in = (ecall_ret_float_args_t*)input_buffer;
    ecall_ret_float_args_t* pargs_out = (ecall_ret_float_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_float(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_double(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_double_args_t* pargs_in = (ecall_ret_double_args_t*)input_buffer;
    ecall_ret_double_args_t* pargs_out = (ecall_ret_double_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_double(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_long_args_t* pargs_in = (ecall_ret_long_args_t*)input_buffer;
    ecall_ret_long_args_t* pargs_out = (ecall_ret_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_long(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_size_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_size_t_args_t* pargs_in = (ecall_ret_size_t_args_t*)input_buffer;
    ecall_ret_size_t_args_t* pargs_out = (ecall_ret_size_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_size_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_unsigned(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_unsigned_args_t* pargs_in = (ecall_ret_unsigned_args_t*)input_buffer;
    ecall_ret_unsigned_args_t* pargs_out = (ecall_ret_unsigned_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_unsigned(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_int8_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_int8_t_args_t* pargs_in = (ecall_ret_int8_t_args_t*)input_buffer;
    ecall_ret_int8_t_args_t* pargs_out = (ecall_ret_int8_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_int8_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_int16_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_int16_t_args_t* pargs_in = (ecall_ret_int16_t_args_t*)input_buffer;
    ecall_ret_int16_t_args_t* pargs_out = (ecall_ret_int16_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_int16_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_int32_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_int32_t_args_t* pargs_in = (ecall_ret_int32_t_args_t*)input_buffer;
    ecall_ret_int32_t_args_t* pargs_out = (ecall_ret_int32_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_int32_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_int64_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_int64_t_args_t* pargs_in = (ecall_ret_int64_t_args_t*)input_buffer;
    ecall_ret_int64_t_args_t* pargs_out = (ecall_ret_int64_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_int64_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_uint8_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_uint8_t_args_t* pargs_in = (ecall_ret_uint8_t_args_t*)input_buffer;
    ecall_ret_uint8_t_args_t* pargs_out = (ecall_ret_uint8_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_uint8_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_uint16_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_uint16_t_args_t* pargs_in = (ecall_ret_uint16_t_args_t*)input_buffer;
    ecall_ret_uint16_t_args_t* pargs_out = (ecall_ret_uint16_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_uint16_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_uint32_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_uint32_t_args_t* pargs_in = (ecall_ret_uint32_t_args_t*)input_buffer;
    ecall_ret_uint32_t_args_t* pargs_out = (ecall_ret_uint32_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_uint32_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_uint64_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_uint64_t_args_t* pargs_in = (ecall_ret_uint64_t_args_t*)input_buffer;
    ecall_ret_uint64_t_args_t* pargs_out = (ecall_ret_uint64_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_uint64_t(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_long_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_long_long_args_t* pargs_in = (ecall_ret_long_long_args_t*)input_buffer;
    ecall_ret_long_long_args_t* pargs_out = (ecall_ret_long_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_long_long(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_unsigned_char(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_unsigned_char_args_t* pargs_in = (ecall_ret_unsigned_char_args_t*)input_buffer;
    ecall_ret_unsigned_char_args_t* pargs_out = (ecall_ret_unsigned_char_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_unsigned_char(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_unsigned_short(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_unsigned_short_args_t* pargs_in = (ecall_ret_unsigned_short_args_t*)input_buffer;
    ecall_ret_unsigned_short_args_t* pargs_out = (ecall_ret_unsigned_short_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_unsigned_short(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_unsigned_int(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_unsigned_int_args_t* pargs_in = (ecall_ret_unsigned_int_args_t*)input_buffer;
    ecall_ret_unsigned_int_args_t* pargs_out = (ecall_ret_unsigned_int_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_unsigned_int(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_unsigned_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_unsigned_long_args_t* pargs_in = (ecall_ret_unsigned_long_args_t*)input_buffer;
    ecall_ret_unsigned_long_args_t* pargs_out = (ecall_ret_unsigned_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_unsigned_long(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_long_double(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_long_double_args_t* pargs_in = (ecall_ret_long_double_args_t*)input_buffer;
    ecall_ret_long_double_args_t* pargs_out = (ecall_ret_long_double_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_long_double(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_unsigned_long_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_unsigned_long_long_args_t* pargs_in = (ecall_ret_unsigned_long_long_args_t*)input_buffer;
    ecall_ret_unsigned_long_long_args_t* pargs_out = (ecall_ret_unsigned_long_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_ret_unsigned_long_long(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_ret_void(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_ret_void_args_t* pargs_in = (ecall_ret_void_args_t*)input_buffer;
    ecall_ret_void_args_t* pargs_out = (ecall_ret_void_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_ret_void(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_basic_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_basic_edl_ocalls_args_t* pargs_in = (test_basic_edl_ocalls_args_t*)input_buffer;
    test_basic_edl_ocalls_args_t* pargs_out = (test_basic_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_basic_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_value(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_value_args_t* pargs_in = (deepcopy_value_args_t*)input_buffer;
    deepcopy_value_args_t* pargs_out = (deepcopy_value_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_value(
        pargs_in->s,
        pargs_in->ptr);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_shallow(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_shallow_args_t* pargs_in = (deepcopy_shallow_args_t*)input_buffer;
    deepcopy_shallow_args_t* pargs_out = (deepcopy_shallow_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(ShallowStruct)), ShallowStruct*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(ShallowStruct)), ShallowStruct*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_shallow(
        pargs_in->s,
        pargs_in->ptr);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_count(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_count_args_t* pargs_in = (deepcopy_count_args_t*)input_buffer;
    deepcopy_count_args_t* pargs_out = (deepcopy_count_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(CountStruct)), CountStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, (3 * sizeof(uint64_t)), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(CountStruct)), CountStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, (3 * sizeof(uint64_t)), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_count(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_countparam(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_countparam_args_t* pargs_in = (deepcopy_countparam_args_t*)input_buffer;
    deepcopy_countparam_args_t* pargs_out = (deepcopy_countparam_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(CountParamStruct)), CountParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->count * sizeof(uint64_t)), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(CountParamStruct)), CountParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->count * sizeof(uint64_t)), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_countparam(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_sizeparam(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_sizeparam_args_t* pargs_in = (deepcopy_sizeparam_args_t*)input_buffer;
    deepcopy_sizeparam_args_t* pargs_out = (deepcopy_sizeparam_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(SizeParamStruct)), SizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, pargs_in->s->size, uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(SizeParamStruct)), SizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, pargs_in->s->size, uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_sizeparam(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_countsizeparam(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_countsizeparam_args_t* pargs_in = (deepcopy_countsizeparam_args_t*)input_buffer;
    deepcopy_countsizeparam_args_t* pargs_out = (deepcopy_countsizeparam_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->size * pargs_in->s->count), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->size * pargs_in->s->count), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_countsizeparam(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_countsizeparam_size(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_countsizeparam_size_args_t* pargs_in = (deepcopy_countsizeparam_size_args_t*)input_buffer;
    deepcopy_countsizeparam_size_args_t* pargs_out = (deepcopy_countsizeparam_size_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->size * pargs_in->s->count), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->size * pargs_in->s->count), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_countsizeparam_size(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_countsizeparam_count(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_countsizeparam_count_args_t* pargs_in = (deepcopy_countsizeparam_count_args_t*)input_buffer;
    deepcopy_countsizeparam_count_args_t* pargs_out = (deepcopy_countsizeparam_count_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->size * pargs_in->s->count), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, (pargs_in->s->size * pargs_in->s->count), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_countsizeparam_count(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_countparamarray(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_countparamarray_args_t* pargs_in = (deepcopy_countparamarray_args_t*)input_buffer;
    deepcopy_countparamarray_args_t* pargs_out = (deepcopy_countparamarray_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (2 * sizeof(CountParamStruct)), CountParamStruct*);
    for (size_t _i_1 = 0; _i_1 < 2; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].ptr)
            OE_SET_IN_OUT_POINTER(s[_i_1].ptr, (pargs_in->s[_i_1].count * sizeof(uint64_t)), uint64_t*);
    }

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (2 * sizeof(CountParamStruct)), CountParamStruct*);
    for (size_t _i_1 = 0; _i_1 < 2; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].ptr)
            OE_COPY_AND_SET_IN_OUT_POINTER(s[_i_1].ptr, (pargs_in->s[_i_1].count * sizeof(uint64_t)), uint64_t*);
    }

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_countparamarray(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_sizeparamarray(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_sizeparamarray_args_t* pargs_in = (deepcopy_sizeparamarray_args_t*)input_buffer;
    deepcopy_sizeparamarray_args_t* pargs_out = (deepcopy_sizeparamarray_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (2 * sizeof(SizeParamStruct)), SizeParamStruct*);
    for (size_t _i_1 = 0; _i_1 < 2; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].ptr)
            OE_SET_IN_OUT_POINTER(s[_i_1].ptr, pargs_in->s[_i_1].size, uint64_t*);
    }

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (2 * sizeof(SizeParamStruct)), SizeParamStruct*);
    for (size_t _i_1 = 0; _i_1 < 2; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].ptr)
            OE_COPY_AND_SET_IN_OUT_POINTER(s[_i_1].ptr, pargs_in->s[_i_1].size, uint64_t*);
    }

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_sizeparamarray(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_countsizeparamarray(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_countsizeparamarray_args_t* pargs_in = (deepcopy_countsizeparamarray_args_t*)input_buffer;
    deepcopy_countsizeparamarray_args_t* pargs_out = (deepcopy_countsizeparamarray_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (2 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    for (size_t _i_1 = 0; _i_1 < 2; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].ptr)
            OE_SET_IN_OUT_POINTER(s[_i_1].ptr, (pargs_in->s[_i_1].size * pargs_in->s[_i_1].count), uint64_t*);
    }

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (2 * sizeof(CountSizeParamStruct)), CountSizeParamStruct*);
    for (size_t _i_1 = 0; _i_1 < 2; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].ptr)
            OE_COPY_AND_SET_IN_OUT_POINTER(s[_i_1].ptr, (pargs_in->s[_i_1].size * pargs_in->s[_i_1].count), uint64_t*);
    }

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_countsizeparamarray(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_nested(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_nested_args_t* pargs_in = (deepcopy_nested_args_t*)input_buffer;
    deepcopy_nested_args_t* pargs_out = (deepcopy_nested_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->n)
        OE_SET_IN_OUT_POINTER(n, (1 * sizeof(NestedStruct)), NestedStruct*);
    if (pargs_in->n && pargs_in->n->array_of_int)
        OE_SET_IN_OUT_POINTER(n->array_of_int, (4 * sizeof(int)), int*);
    if (pargs_in->n && pargs_in->n->array_of_struct)
        OE_SET_IN_OUT_POINTER(n->array_of_struct, (3 * sizeof(CountStruct)), CountStruct*);
    for (size_t _i_2 = 0; _i_2 < 3; _i_2++)
    {
        if (pargs_in->n && pargs_in->n->array_of_struct && pargs_in->n->array_of_struct[_i_2].ptr)
            OE_SET_IN_OUT_POINTER(n->array_of_struct[_i_2].ptr, (3 * sizeof(uint64_t)), uint64_t*);
    }

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->n)
        OE_COPY_AND_SET_IN_OUT_POINTER(n, (1 * sizeof(NestedStruct)), NestedStruct*);
    if (pargs_in->n && pargs_in->n->array_of_int)
        OE_COPY_AND_SET_IN_OUT_POINTER(n->array_of_int, (4 * sizeof(int)), int*);
    if (pargs_in->n && pargs_in->n->array_of_struct)
        OE_COPY_AND_SET_IN_OUT_POINTER(n->array_of_struct, (3 * sizeof(CountStruct)), CountStruct*);
    for (size_t _i_2 = 0; _i_2 < 3; _i_2++)
    {
        if (pargs_in->n && pargs_in->n->array_of_struct && pargs_in->n->array_of_struct[_i_2].ptr)
            OE_COPY_AND_SET_IN_OUT_POINTER(n->array_of_struct[_i_2].ptr, (3 * sizeof(uint64_t)), uint64_t*);
    }

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_nested(
        pargs_in->n);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_super_nested(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_super_nested_args_t* pargs_in = (deepcopy_super_nested_args_t*)input_buffer;
    deepcopy_super_nested_args_t* pargs_out = (deepcopy_super_nested_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (pargs_in->n * sizeof(SuperNestedStruct)), SuperNestedStruct*);
    for (size_t _i_1 = 0; _i_1 < pargs_in->n; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].more_structs)
            OE_SET_IN_OUT_POINTER(s[_i_1].more_structs, (2 * sizeof(NestedStruct)), NestedStruct*);
        for (size_t _i_2 = 0; _i_2 < 2; _i_2++)
        {
            if (pargs_in->s && pargs_in->s[_i_1].more_structs && pargs_in->s[_i_1].more_structs[_i_2].array_of_int)
                OE_SET_IN_OUT_POINTER(s[_i_1].more_structs[_i_2].array_of_int, (4 * sizeof(int)), int*);
        }
        for (size_t _i_2 = 0; _i_2 < 2; _i_2++)
        {
            if (pargs_in->s && pargs_in->s[_i_1].more_structs && pargs_in->s[_i_1].more_structs[_i_2].array_of_struct)
                OE_SET_IN_OUT_POINTER(s[_i_1].more_structs[_i_2].array_of_struct, (3 * sizeof(CountStruct)), CountStruct*);
            for (size_t _i_3 = 0; _i_3 < 3; _i_3++)
            {
                if (pargs_in->s && pargs_in->s[_i_1].more_structs && pargs_in->s[_i_1].more_structs[_i_2].array_of_struct && pargs_in->s[_i_1].more_structs[_i_2].array_of_struct[_i_3].ptr)
                    OE_SET_IN_OUT_POINTER(s[_i_1].more_structs[_i_2].array_of_struct[_i_3].ptr, (3 * sizeof(uint64_t)), uint64_t*);
            }
        }
    }

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (pargs_in->n * sizeof(SuperNestedStruct)), SuperNestedStruct*);
    for (size_t _i_1 = 0; _i_1 < pargs_in->n; _i_1++)
    {
        if (pargs_in->s && pargs_in->s[_i_1].more_structs)
            OE_COPY_AND_SET_IN_OUT_POINTER(s[_i_1].more_structs, (2 * sizeof(NestedStruct)), NestedStruct*);
        for (size_t _i_2 = 0; _i_2 < 2; _i_2++)
        {
            if (pargs_in->s && pargs_in->s[_i_1].more_structs && pargs_in->s[_i_1].more_structs[_i_2].array_of_int)
                OE_COPY_AND_SET_IN_OUT_POINTER(s[_i_1].more_structs[_i_2].array_of_int, (4 * sizeof(int)), int*);
        }
        for (size_t _i_2 = 0; _i_2 < 2; _i_2++)
        {
            if (pargs_in->s && pargs_in->s[_i_1].more_structs && pargs_in->s[_i_1].more_structs[_i_2].array_of_struct)
                OE_COPY_AND_SET_IN_OUT_POINTER(s[_i_1].more_structs[_i_2].array_of_struct, (3 * sizeof(CountStruct)), CountStruct*);
            for (size_t _i_3 = 0; _i_3 < 3; _i_3++)
            {
                if (pargs_in->s && pargs_in->s[_i_1].more_structs && pargs_in->s[_i_1].more_structs[_i_2].array_of_struct && pargs_in->s[_i_1].more_structs[_i_2].array_of_struct[_i_3].ptr)
                    OE_COPY_AND_SET_IN_OUT_POINTER(s[_i_1].more_structs[_i_2].array_of_struct[_i_3].ptr, (3 * sizeof(uint64_t)), uint64_t*);
            }
        }
    }

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_super_nested(
        pargs_in->s,
        pargs_in->n);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_null(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_null_args_t* pargs_in = (deepcopy_null_args_t*)input_buffer;
    deepcopy_null_args_t* pargs_out = (deepcopy_null_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(CountStruct)), CountStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, (3 * sizeof(uint64_t)), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(CountStruct)), CountStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, (3 * sizeof(uint64_t)), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_null(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_out_count(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_out_count_args_t* pargs_in = (deepcopy_out_count_args_t*)input_buffer;
    deepcopy_out_count_args_t* pargs_out = (deepcopy_out_count_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, (1 * sizeof(CountStruct)), CountStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_SET_IN_OUT_POINTER(s->ptr, (3 * sizeof(uint64_t)), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, (1 * sizeof(CountStruct)), CountStruct*);
    if (pargs_in->s && pargs_in->s->ptr)
        OE_COPY_AND_SET_IN_OUT_POINTER(s->ptr, (3 * sizeof(uint64_t)), uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_out_count(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_deepcopy_iovec(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    deepcopy_iovec_args_t* pargs_in = (deepcopy_iovec_args_t*)input_buffer;
    deepcopy_iovec_args_t* pargs_out = (deepcopy_iovec_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->iov)
        OE_SET_IN_OUT_POINTER(iov, (pargs_in->n * sizeof(IOVEC)), IOVEC*);
    for (size_t _i_1 = 0; _i_1 < pargs_in->n; _i_1++)
    {
        if (pargs_in->iov && pargs_in->iov[_i_1].base)
            OE_SET_IN_OUT_POINTER(iov[_i_1].base, pargs_in->iov[_i_1].len, void*);
    }

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->iov)
        OE_COPY_AND_SET_IN_OUT_POINTER(iov, (pargs_in->n * sizeof(IOVEC)), IOVEC*);
    for (size_t _i_1 = 0; _i_1 < pargs_in->n; _i_1++)
    {
        if (pargs_in->iov && pargs_in->iov[_i_1].base)
            OE_COPY_AND_SET_IN_OUT_POINTER(iov[_i_1].base, pargs_in->iov[_i_1].len, void*);
    }

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    deepcopy_iovec(
        pargs_in->iov,
        pargs_in->n);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_enum1(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_enum1_args_t* pargs_in = (ecall_enum1_args_t*)input_buffer;
    ecall_enum1_args_t* pargs_out = (ecall_enum1_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a2)
        OE_SET_IN_POINTER(a2, sizeof(Color[5]), Color*);
    if (pargs_in->a3)
        OE_SET_IN_OUT_POINTER(a3, sizeof(Color[5][5]), Color*);
    if (pargs_in->a5)
        OE_SET_IN_POINTER(a5, sizeof(Color), Color*);
    if (pargs_in->a6)
        OE_SET_IN_OUT_POINTER(a6, sizeof(Color), Color*);
    if (pargs_in->a8)
        OE_SET_IN_POINTER(a8, (5 * sizeof(Color)), Color*);
    if (pargs_in->a9)
        OE_SET_IN_OUT_POINTER(a9, (5 * sizeof(Color)), Color*);
    if (pargs_in->a11)
        OE_SET_IN_POINTER(a11, 8, Color*);
    if (pargs_in->a12)
        OE_SET_IN_OUT_POINTER(a12, 8, Color*);
    if (pargs_in->a14)
        OE_SET_IN_POINTER(a14, (pargs_in->count * sizeof(Color)), Color*);
    if (pargs_in->a15)
        OE_SET_IN_OUT_POINTER(a15, (pargs_in->count * sizeof(Color)), Color*);
    if (pargs_in->a17)
        OE_SET_IN_POINTER(a17, pargs_in->size, Color*);
    if (pargs_in->a18)
        OE_SET_IN_OUT_POINTER(a18, pargs_in->size, Color*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a3)
        OE_COPY_AND_SET_IN_OUT_POINTER(a3, sizeof(Color[5][5]), Color*);
    if (pargs_in->a4)
        OE_SET_OUT_POINTER(a4, sizeof(Color[1][1][1]), Color*);
    if (pargs_in->a6)
        OE_COPY_AND_SET_IN_OUT_POINTER(a6, sizeof(Color), Color*);
    if (pargs_in->a7)
        OE_SET_OUT_POINTER(a7, sizeof(Color), Color*);
    if (pargs_in->a9)
        OE_COPY_AND_SET_IN_OUT_POINTER(a9, (5 * sizeof(Color)), Color*);
    if (pargs_in->a10)
        OE_SET_OUT_POINTER(a10, (5 * sizeof(Color)), Color*);
    if (pargs_in->a12)
        OE_COPY_AND_SET_IN_OUT_POINTER(a12, 8, Color*);
    if (pargs_in->a13)
        OE_SET_OUT_POINTER(a13, 8, Color*);
    if (pargs_in->a15)
        OE_COPY_AND_SET_IN_OUT_POINTER(a15, (pargs_in->count * sizeof(Color)), Color*);
    if (pargs_in->a16)
        OE_SET_OUT_POINTER(a16, (pargs_in->count * sizeof(Color)), Color*);
    if (pargs_in->a18)
        OE_COPY_AND_SET_IN_OUT_POINTER(a18, pargs_in->size, Color*);
    if (pargs_in->a19)
        OE_SET_OUT_POINTER(a19, pargs_in->size, Color*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_enum1(
        pargs_in->a1,
        *(Color(*)[5])pargs_in->a2,
        *(Color(*)[5][5])pargs_in->a3,
        *(Color(*)[1][1][1])pargs_in->a4,
        pargs_in->a5,
        pargs_in->a6,
        pargs_in->a7,
        pargs_in->a8,
        pargs_in->a9,
        pargs_in->a10,
        pargs_in->a11,
        pargs_in->a12,
        pargs_in->a13,
        pargs_in->a14,
        pargs_in->a15,
        pargs_in->a16,
        pargs_in->a17,
        pargs_in->a18,
        pargs_in->a19,
        pargs_in->count,
        pargs_in->size);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_enum_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_enum_edl_ocalls_args_t* pargs_in = (test_enum_edl_ocalls_args_t*)input_buffer;
    test_enum_edl_ocalls_args_t* pargs_out = (test_enum_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_enum_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_errno_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_errno_edl_ocalls_args_t* pargs_in = (test_errno_edl_ocalls_args_t*)input_buffer;
    test_errno_edl_ocalls_args_t* pargs_out = (test_errno_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_errno_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_ptr_1(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_ptr_1_args_t* pargs_in = (ecall_foreign_ptr_1_args_t*)input_buffer;
    ecall_foreign_ptr_1_args_t* pargs_out = (ecall_foreign_ptr_1_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(my_type1), my_type1*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(my_type1), my_type1*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(my_type1), my_type1*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(my_type1), my_type1*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_ptr_1(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_ptr_2(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_ptr_2_args_t* pargs_in = (ecall_foreign_ptr_2_args_t*)input_buffer;
    ecall_foreign_ptr_2_args_t* pargs_out = (ecall_foreign_ptr_2_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, (5 * sizeof(my_type1)), my_type1*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, (5 * sizeof(my_type1)), my_type1*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, (5 * sizeof(my_type1)), my_type1*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, (5 * sizeof(my_type1)), my_type1*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_ptr_2(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_ptr_3(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_ptr_3_args_t* pargs_in = (ecall_foreign_ptr_3_args_t*)input_buffer;
    ecall_foreign_ptr_3_args_t* pargs_out = (ecall_foreign_ptr_3_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, 64, my_type1*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, 64, my_type1*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, 64, my_type1*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, 64, my_type1*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_ptr_3(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_ptr_4(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_ptr_4_args_t* pargs_in = (ecall_foreign_ptr_4_args_t*)input_buffer;
    ecall_foreign_ptr_4_args_t* pargs_out = (ecall_foreign_ptr_4_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, (pargs_in->count * sizeof(my_type1)), my_type1*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, (pargs_in->count * sizeof(my_type1)), my_type1*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, (pargs_in->count * sizeof(my_type1)), my_type1*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, (pargs_in->count * sizeof(my_type1)), my_type1*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_ptr_4(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3,
        pargs_in->count);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_ptr_5(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_ptr_5_args_t* pargs_in = (ecall_foreign_ptr_5_args_t*)input_buffer;
    ecall_foreign_ptr_5_args_t* pargs_out = (ecall_foreign_ptr_5_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, pargs_in->size, my_type1*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, pargs_in->size, my_type1*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, pargs_in->size, my_type1*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, pargs_in->size, my_type1*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_ptr_5(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3,
        pargs_in->size);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_isptr_1(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_isptr_1_args_t* pargs_in = (ecall_foreign_isptr_1_args_t*)input_buffer;
    ecall_foreign_isptr_1_args_t* pargs_out = (ecall_foreign_isptr_1_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(*(my_type2)0), my_type2);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(*(my_type2)0), my_type2);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(*(my_type2)0), my_type2);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(*(my_type2)0), my_type2);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_isptr_1(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_isptr_2(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_isptr_2_args_t* pargs_in = (ecall_foreign_isptr_2_args_t*)input_buffer;
    ecall_foreign_isptr_2_args_t* pargs_out = (ecall_foreign_isptr_2_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, (5 * sizeof(*(my_type2)0)), my_type2);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, (5 * sizeof(*(my_type2)0)), my_type2);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, (5 * sizeof(*(my_type2)0)), my_type2);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, (5 * sizeof(*(my_type2)0)), my_type2);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_isptr_2(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_isptr_3(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_isptr_3_args_t* pargs_in = (ecall_foreign_isptr_3_args_t*)input_buffer;
    ecall_foreign_isptr_3_args_t* pargs_out = (ecall_foreign_isptr_3_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, 64, my_type2);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, 64, my_type2);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, 64, my_type2);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, 64, my_type2);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_isptr_3(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_isptr_4(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_isptr_4_args_t* pargs_in = (ecall_foreign_isptr_4_args_t*)input_buffer;
    ecall_foreign_isptr_4_args_t* pargs_out = (ecall_foreign_isptr_4_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, (pargs_in->count * sizeof(*(my_type2)0)), my_type2);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, (pargs_in->count * sizeof(*(my_type2)0)), my_type2);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, (pargs_in->count * sizeof(*(my_type2)0)), my_type2);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, (pargs_in->count * sizeof(*(my_type2)0)), my_type2);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_isptr_4(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3,
        pargs_in->count);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_isptr_5(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_isptr_5_args_t* pargs_in = (ecall_foreign_isptr_5_args_t*)input_buffer;
    ecall_foreign_isptr_5_args_t* pargs_out = (ecall_foreign_isptr_5_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, pargs_in->size, my_type2);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, pargs_in->size, my_type2);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, pargs_in->size, my_type2);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, pargs_in->size, my_type2);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_isptr_5(
        pargs_in->a1,
        pargs_in->a2,
        pargs_in->a3,
        pargs_in->size);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_isary(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_isary_args_t* pargs_in = (ecall_foreign_isary_args_t*)input_buffer;
    ecall_foreign_isary_args_t* pargs_out = (ecall_foreign_isary_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a1)
        OE_SET_IN_POINTER(a1, sizeof(my_type3), /* foreign array of type my_type3 */ void*);
    if (pargs_in->a2)
        OE_SET_IN_OUT_POINTER(a2, sizeof(my_type3), /* foreign array of type my_type3 */ void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a2)
        OE_COPY_AND_SET_IN_OUT_POINTER(a2, sizeof(my_type3), /* foreign array of type my_type3 */ void*);
    if (pargs_in->a3)
        OE_SET_OUT_POINTER(a3, sizeof(my_type3), /* foreign array of type my_type3 */ void*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_foreign_isary(
        /* foreign array */ *(my_type3*)pargs_in->a1,
        /* foreign array */ *(my_type3*)pargs_in->a2,
        /* foreign array */ *(my_type3*)pargs_in->a3);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_foreign_value(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_foreign_value_args_t* pargs_in = (ecall_foreign_value_args_t*)input_buffer;
    ecall_foreign_value_args_t* pargs_out = (ecall_foreign_value_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_foreign_value(
        pargs_in->a1);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_foreign_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_foreign_edl_ocalls_args_t* pargs_in = (test_foreign_edl_ocalls_args_t*)input_buffer;
    test_foreign_edl_ocalls_args_t* pargs_out = (test_foreign_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_foreign_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_char(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_char_args_t* pargs_in = (ecall_pointer_char_args_t*)input_buffer;
    ecall_pointer_char_args_t* pargs_out = (ecall_pointer_char_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(char), char*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(char), char*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(char)), char*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(char)), char*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, char*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, char*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, char*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(char)), char*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(char)), char*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, char*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(char), char*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(char), char*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(char)), char*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(char)), char*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, char*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(char)), char*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(char)), char*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, char*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, char*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_char(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_wchar_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_wchar_t_args_t* pargs_in = (ecall_pointer_wchar_t_args_t*)input_buffer;
    ecall_pointer_wchar_t_args_t* pargs_out = (ecall_pointer_wchar_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(wchar_t), wchar_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(wchar_t), wchar_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, wchar_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, wchar_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, wchar_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, wchar_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, wchar_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(wchar_t), wchar_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(wchar_t), wchar_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, wchar_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(wchar_t)), wchar_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, wchar_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, wchar_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_wchar_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_short(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_short_args_t* pargs_in = (ecall_pointer_short_args_t*)input_buffer;
    ecall_pointer_short_args_t* pargs_out = (ecall_pointer_short_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(short int), short int*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(short int), short int*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(short int)), short int*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(short int)), short int*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, short int*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, short int*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, short int*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(short int)), short int*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(short int)), short int*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, short int*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, short int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(short int), short int*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(short int), short int*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(short int)), short int*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(short int)), short int*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, short int*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(short int)), short int*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(short int)), short int*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, short int*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, short int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_short(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_int(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_int_args_t* pargs_in = (ecall_pointer_int_args_t*)input_buffer;
    ecall_pointer_int_args_t* pargs_out = (ecall_pointer_int_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(int), int*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(int), int*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(int)), int*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(int)), int*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, int*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, int*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, int*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(int)), int*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int)), int*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, int*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(int), int*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(int), int*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(int)), int*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(int)), int*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, int*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int)), int*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(int)), int*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, int*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_int(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_float(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_float_args_t* pargs_in = (ecall_pointer_float_args_t*)input_buffer;
    ecall_pointer_float_args_t* pargs_out = (ecall_pointer_float_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(float), float*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(float), float*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(float)), float*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(float)), float*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, float*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, float*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, float*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(float)), float*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(float)), float*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, float*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, float*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(float), float*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(float), float*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(float)), float*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(float)), float*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, float*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(float)), float*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(float)), float*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, float*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, float*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_float(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_double(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_double_args_t* pargs_in = (ecall_pointer_double_args_t*)input_buffer;
    ecall_pointer_double_args_t* pargs_out = (ecall_pointer_double_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(double), double*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(double), double*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(double)), double*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(double)), double*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, double*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, double*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, double*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(double)), double*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(double)), double*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, double*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, double*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(double), double*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(double), double*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(double)), double*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(double)), double*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, double*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(double)), double*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(double)), double*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, double*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, double*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_double(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_long_args_t* pargs_in = (ecall_pointer_long_args_t*)input_buffer;
    ecall_pointer_long_args_t* pargs_out = (ecall_pointer_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(long int), long int*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(long int), long int*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(long int)), long int*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(long int)), long int*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, long int*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, long int*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, long int*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(long int)), long int*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(long int)), long int*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, long int*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, long int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(long int), long int*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(long int), long int*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(long int)), long int*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(long int)), long int*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, long int*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(long int)), long int*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(long int)), long int*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, long int*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, long int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_long(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_size_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_size_t_args_t* pargs_in = (ecall_pointer_size_t_args_t*)input_buffer;
    ecall_pointer_size_t_args_t* pargs_out = (ecall_pointer_size_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(size_t), size_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(size_t), size_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(size_t)), size_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(size_t)), size_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, size_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, size_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, size_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(size_t)), size_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(size_t)), size_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, size_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, size_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(size_t), size_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(size_t), size_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(size_t)), size_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(size_t)), size_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, size_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(size_t)), size_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(size_t)), size_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, size_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, size_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_size_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_unsigned(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_unsigned_args_t* pargs_in = (ecall_pointer_unsigned_args_t*)input_buffer;
    ecall_pointer_unsigned_args_t* pargs_out = (ecall_pointer_unsigned_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, unsigned int*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, unsigned int*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, unsigned int*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, unsigned int*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, unsigned int*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned int*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, unsigned int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_unsigned(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_int8_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_int8_t_args_t* pargs_in = (ecall_pointer_int8_t_args_t*)input_buffer;
    ecall_pointer_int8_t_args_t* pargs_out = (ecall_pointer_int8_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(int8_t), int8_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(int8_t), int8_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(int8_t)), int8_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(int8_t)), int8_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, int8_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, int8_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, int8_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(int8_t)), int8_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int8_t)), int8_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, int8_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, int8_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(int8_t), int8_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(int8_t), int8_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(int8_t)), int8_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(int8_t)), int8_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, int8_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int8_t)), int8_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(int8_t)), int8_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, int8_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, int8_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_int8_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_int16_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_int16_t_args_t* pargs_in = (ecall_pointer_int16_t_args_t*)input_buffer;
    ecall_pointer_int16_t_args_t* pargs_out = (ecall_pointer_int16_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(int16_t), int16_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(int16_t), int16_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(int16_t)), int16_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(int16_t)), int16_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, int16_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, int16_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, int16_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(int16_t)), int16_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int16_t)), int16_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, int16_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, int16_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(int16_t), int16_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(int16_t), int16_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(int16_t)), int16_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(int16_t)), int16_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, int16_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int16_t)), int16_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(int16_t)), int16_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, int16_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, int16_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_int16_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_int32_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_int32_t_args_t* pargs_in = (ecall_pointer_int32_t_args_t*)input_buffer;
    ecall_pointer_int32_t_args_t* pargs_out = (ecall_pointer_int32_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(int32_t), int32_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(int32_t), int32_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(int32_t)), int32_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(int32_t)), int32_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, int32_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, int32_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, int32_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(int32_t)), int32_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int32_t)), int32_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, int32_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, int32_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(int32_t), int32_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(int32_t), int32_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(int32_t)), int32_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(int32_t)), int32_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, int32_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int32_t)), int32_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(int32_t)), int32_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, int32_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, int32_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_int32_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_int64_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_int64_t_args_t* pargs_in = (ecall_pointer_int64_t_args_t*)input_buffer;
    ecall_pointer_int64_t_args_t* pargs_out = (ecall_pointer_int64_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(int64_t), int64_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(int64_t), int64_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(int64_t)), int64_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(int64_t)), int64_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, int64_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, int64_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, int64_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(int64_t)), int64_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int64_t)), int64_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, int64_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, int64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(int64_t), int64_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(int64_t), int64_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(int64_t)), int64_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(int64_t)), int64_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, int64_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(int64_t)), int64_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(int64_t)), int64_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, int64_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, int64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_int64_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_uint8_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_uint8_t_args_t* pargs_in = (ecall_pointer_uint8_t_args_t*)input_buffer;
    ecall_pointer_uint8_t_args_t* pargs_out = (ecall_pointer_uint8_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(uint8_t), uint8_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(uint8_t), uint8_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, uint8_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, uint8_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, uint8_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, uint8_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint8_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(uint8_t), uint8_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(uint8_t), uint8_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, uint8_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(uint8_t)), uint8_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint8_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, uint8_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_uint8_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_uint16_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_uint16_t_args_t* pargs_in = (ecall_pointer_uint16_t_args_t*)input_buffer;
    ecall_pointer_uint16_t_args_t* pargs_out = (ecall_pointer_uint16_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(uint16_t), uint16_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(uint16_t), uint16_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, uint16_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, uint16_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, uint16_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, uint16_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint16_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(uint16_t), uint16_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(uint16_t), uint16_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, uint16_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(uint16_t)), uint16_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint16_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, uint16_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_uint16_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_uint32_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_uint32_t_args_t* pargs_in = (ecall_pointer_uint32_t_args_t*)input_buffer;
    ecall_pointer_uint32_t_args_t* pargs_out = (ecall_pointer_uint32_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(uint32_t), uint32_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(uint32_t), uint32_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, uint32_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, uint32_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, uint32_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, uint32_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint32_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(uint32_t), uint32_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(uint32_t), uint32_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, uint32_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(uint32_t)), uint32_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint32_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, uint32_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_uint32_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_uint64_t(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_uint64_t_args_t* pargs_in = (ecall_pointer_uint64_t_args_t*)input_buffer;
    ecall_pointer_uint64_t_args_t* pargs_out = (ecall_pointer_uint64_t_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(uint64_t), uint64_t*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(uint64_t), uint64_t*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, uint64_t*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, uint64_t*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, uint64_t*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, uint64_t*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(uint64_t), uint64_t*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(uint64_t), uint64_t*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, uint64_t*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(uint64_t)), uint64_t*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, uint64_t*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, uint64_t*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_uint64_t(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_long_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_long_long_args_t* pargs_in = (ecall_pointer_long_long_args_t*)input_buffer;
    ecall_pointer_long_long_args_t* pargs_out = (ecall_pointer_long_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(long long), long long*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(long long), long long*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(long long)), long long*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(long long)), long long*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, long long*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, long long*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, long long*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(long long)), long long*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(long long)), long long*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, long long*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, long long*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(long long), long long*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(long long), long long*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(long long)), long long*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(long long)), long long*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, long long*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(long long)), long long*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(long long)), long long*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, long long*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, long long*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_long_long(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_unsigned_char(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_unsigned_char_args_t* pargs_in = (ecall_pointer_unsigned_char_args_t*)input_buffer;
    ecall_pointer_unsigned_char_args_t* pargs_out = (ecall_pointer_unsigned_char_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(unsigned char), unsigned char*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(unsigned char), unsigned char*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, unsigned char*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, unsigned char*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, unsigned char*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, unsigned char*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(unsigned char), unsigned char*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(unsigned char), unsigned char*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, unsigned char*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(unsigned char)), unsigned char*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned char*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, unsigned char*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_unsigned_char(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_unsigned_short(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_unsigned_short_args_t* pargs_in = (ecall_pointer_unsigned_short_args_t*)input_buffer;
    ecall_pointer_unsigned_short_args_t* pargs_out = (ecall_pointer_unsigned_short_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(unsigned short int), unsigned short int*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(unsigned short int), unsigned short int*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, unsigned short int*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, unsigned short int*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, unsigned short int*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, unsigned short int*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned short int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(unsigned short int), unsigned short int*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(unsigned short int), unsigned short int*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, unsigned short int*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(unsigned short int)), unsigned short int*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned short int*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, unsigned short int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_unsigned_short(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_unsigned_int(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_unsigned_int_args_t* pargs_in = (ecall_pointer_unsigned_int_args_t*)input_buffer;
    ecall_pointer_unsigned_int_args_t* pargs_out = (ecall_pointer_unsigned_int_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, unsigned int*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, unsigned int*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, unsigned int*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, unsigned int*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(unsigned int), unsigned int*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, unsigned int*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(unsigned int)), unsigned int*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned int*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, unsigned int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_unsigned_int(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_unsigned_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_unsigned_long_args_t* pargs_in = (ecall_pointer_unsigned_long_args_t*)input_buffer;
    ecall_pointer_unsigned_long_args_t* pargs_out = (ecall_pointer_unsigned_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(unsigned long int), unsigned long int*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(unsigned long int), unsigned long int*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, unsigned long int*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, unsigned long int*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, unsigned long int*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, unsigned long int*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned long int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(unsigned long int), unsigned long int*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(unsigned long int), unsigned long int*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, unsigned long int*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(unsigned long int)), unsigned long int*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned long int*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, unsigned long int*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_unsigned_long(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_unsigned_long_long(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_unsigned_long_long_args_t* pargs_in = (ecall_pointer_unsigned_long_long_args_t*)input_buffer;
    ecall_pointer_unsigned_long_long_args_t* pargs_out = (ecall_pointer_unsigned_long_long_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(unsigned long long), unsigned long long*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(unsigned long long), unsigned long long*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, unsigned long long*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, unsigned long long*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, unsigned long long*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, unsigned long long*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned long long*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(unsigned long long), unsigned long long*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(unsigned long long), unsigned long long*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, unsigned long long*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(unsigned long long)), unsigned long long*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, unsigned long long*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, unsigned long long*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_unsigned_long_long(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_long_double(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_long_double_args_t* pargs_in = (ecall_pointer_long_double_args_t*)input_buffer;
    ecall_pointer_long_double_args_t* pargs_out = (ecall_pointer_long_double_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->p1)
        OE_SET_IN_POINTER(p1, sizeof(long double), long double*);
    if (pargs_in->p2)
        OE_SET_IN_OUT_POINTER(p2, sizeof(long double), long double*);
    if (pargs_in->p4)
        OE_SET_IN_POINTER(p4, (16 * sizeof(long double)), long double*);
    if (pargs_in->p5)
        OE_SET_IN_OUT_POINTER(p5, (16 * sizeof(long double)), long double*);
    if (pargs_in->p7)
        OE_SET_IN_POINTER(p7, 80, long double*);
    if (pargs_in->p8)
        OE_SET_IN_OUT_POINTER(p8, 80, long double*);
    if (pargs_in->p9)
        OE_SET_IN_POINTER(p9, 80, long double*);
    if (pargs_in->p11)
        OE_SET_IN_POINTER(p11, (pargs_in->pcount * sizeof(long double)), long double*);
    if (pargs_in->p12)
        OE_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(long double)), long double*);
    if (pargs_in->p14)
        OE_SET_IN_POINTER(p14, pargs_in->psize, long double*);
    if (pargs_in->p15)
        OE_SET_IN_OUT_POINTER(p15, pargs_in->psize, long double*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->p2)
        OE_COPY_AND_SET_IN_OUT_POINTER(p2, sizeof(long double), long double*);
    if (pargs_in->p3)
        OE_SET_OUT_POINTER(p3, sizeof(long double), long double*);
    if (pargs_in->p5)
        OE_COPY_AND_SET_IN_OUT_POINTER(p5, (16 * sizeof(long double)), long double*);
    if (pargs_in->p6)
        OE_SET_OUT_POINTER(p6, (16 * sizeof(long double)), long double*);
    if (pargs_in->p8)
        OE_COPY_AND_SET_IN_OUT_POINTER(p8, 80, long double*);
    if (pargs_in->p12)
        OE_COPY_AND_SET_IN_OUT_POINTER(p12, (pargs_in->pcount * sizeof(long double)), long double*);
    if (pargs_in->p13)
        OE_SET_OUT_POINTER(p13, (pargs_in->pcount * sizeof(long double)), long double*);
    if (pargs_in->p15)
        OE_COPY_AND_SET_IN_OUT_POINTER(p15, pargs_in->psize, long double*);
    if (pargs_in->p16)
        OE_SET_OUT_POINTER(p16, pargs_in->psize, long double*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_pointer_long_double(
        pargs_in->p1,
        pargs_in->p2,
        pargs_in->p3,
        pargs_in->p4,
        pargs_in->p5,
        pargs_in->p6,
        pargs_in->p7,
        pargs_in->p8,
        pargs_in->p9,
        pargs_in->p10,
        pargs_in->p11,
        pargs_in->p12,
        pargs_in->p13,
        pargs_in->p14,
        pargs_in->p15,
        pargs_in->p16,
        pargs_in->pcount,
        pargs_in->psize);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_count_attribute_all_types(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_count_attribute_all_types_args_t* pargs_in = (ecall_count_attribute_all_types_args_t*)input_buffer;
    ecall_count_attribute_all_types_args_t* pargs_out = (ecall_count_attribute_all_types_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->b1)
        OE_SET_IN_POINTER(b1, (pargs_in->char_count * sizeof(int)), int*);
    if (pargs_in->b2)
        OE_SET_IN_POINTER(b2, (pargs_in->short_count * sizeof(int)), int*);
    if (pargs_in->b3)
        OE_SET_IN_POINTER(b3, (pargs_in->int_count * sizeof(int)), int*);
    if (pargs_in->b4)
        OE_SET_IN_POINTER(b4, (pargs_in->float_count * sizeof(int)), int*);
    if (pargs_in->b5)
        OE_SET_IN_POINTER(b5, (pargs_in->double_count * sizeof(int)), int*);
    if (pargs_in->b6)
        OE_SET_IN_POINTER(b6, (pargs_in->long_count * sizeof(int)), int*);
    if (pargs_in->b7)
        OE_SET_IN_POINTER(b7, (pargs_in->size_t_count * sizeof(int)), int*);
    if (pargs_in->b8)
        OE_SET_IN_POINTER(b8, (pargs_in->unsigned_count * sizeof(int)), int*);
    if (pargs_in->b9)
        OE_SET_IN_POINTER(b9, (pargs_in->int8_t_count * sizeof(int)), int*);
    if (pargs_in->b10)
        OE_SET_IN_POINTER(b10, (pargs_in->int16_t_count * sizeof(int)), int*);
    if (pargs_in->b11)
        OE_SET_IN_POINTER(b11, (pargs_in->int32_t_count * sizeof(int)), int*);
    if (pargs_in->b12)
        OE_SET_IN_POINTER(b12, (pargs_in->int64_t_count * sizeof(int)), int*);
    if (pargs_in->b13)
        OE_SET_IN_POINTER(b13, (pargs_in->uint8_t_count * sizeof(int)), int*);
    if (pargs_in->b14)
        OE_SET_IN_POINTER(b14, (pargs_in->uint16_t_count * sizeof(int)), int*);
    if (pargs_in->b15)
        OE_SET_IN_POINTER(b15, (pargs_in->uint32_t_count * sizeof(int)), int*);
    if (pargs_in->b16)
        OE_SET_IN_POINTER(b16, (pargs_in->uint64_t_count * sizeof(int)), int*);
    if (pargs_in->b17)
        OE_SET_IN_POINTER(b17, (pargs_in->wchar_t_count * sizeof(int)), int*);
    if (pargs_in->b18)
        OE_SET_IN_POINTER(b18, (pargs_in->long_long_count * sizeof(int)), int*);
    if (pargs_in->b19)
        OE_SET_IN_POINTER(b19, (pargs_in->long_double_count * sizeof(int)), int*);
    if (pargs_in->b20)
        OE_SET_IN_POINTER(b20, (pargs_in->unsigned_char_count * sizeof(int)), int*);
    if (pargs_in->b21)
        OE_SET_IN_POINTER(b21, (pargs_in->unsigned_short_count * sizeof(int)), int*);
    if (pargs_in->b22)
        OE_SET_IN_POINTER(b22, (pargs_in->unsigned_int_count * sizeof(int)), int*);
    if (pargs_in->b23)
        OE_SET_IN_POINTER(b23, (pargs_in->unsigned_long_count * sizeof(int)), int*);
    if (pargs_in->b24)
        OE_SET_IN_POINTER(b24, (pargs_in->unsigned_long_long_count * sizeof(int)), int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_count_attribute_all_types(
        pargs_in->b1,
        pargs_in->b2,
        pargs_in->b3,
        pargs_in->b4,
        pargs_in->b5,
        pargs_in->b6,
        pargs_in->b7,
        pargs_in->b8,
        pargs_in->b9,
        pargs_in->b10,
        pargs_in->b11,
        pargs_in->b12,
        pargs_in->b13,
        pargs_in->b14,
        pargs_in->b15,
        pargs_in->b16,
        pargs_in->b17,
        pargs_in->b18,
        pargs_in->b19,
        pargs_in->b20,
        pargs_in->b21,
        pargs_in->b22,
        pargs_in->b23,
        pargs_in->b24,
        pargs_in->char_count,
        pargs_in->short_count,
        pargs_in->int_count,
        pargs_in->float_count,
        pargs_in->double_count,
        pargs_in->long_count,
        pargs_in->size_t_count,
        pargs_in->unsigned_count,
        pargs_in->int8_t_count,
        pargs_in->int16_t_count,
        pargs_in->int32_t_count,
        pargs_in->int64_t_count,
        pargs_in->uint8_t_count,
        pargs_in->uint16_t_count,
        pargs_in->uint32_t_count,
        pargs_in->uint64_t_count,
        pargs_in->wchar_t_count,
        pargs_in->long_long_count,
        pargs_in->long_double_count,
        pargs_in->unsigned_char_count,
        pargs_in->unsigned_short_count,
        pargs_in->unsigned_int_count,
        pargs_in->unsigned_long_count,
        pargs_in->unsigned_long_long_count);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_size_attribute_all_types(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_size_attribute_all_types_args_t* pargs_in = (ecall_size_attribute_all_types_args_t*)input_buffer;
    ecall_size_attribute_all_types_args_t* pargs_out = (ecall_size_attribute_all_types_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->b1)
        OE_SET_IN_POINTER(b1, pargs_in->char_size, int*);
    if (pargs_in->b2)
        OE_SET_IN_POINTER(b2, pargs_in->short_size, int*);
    if (pargs_in->b3)
        OE_SET_IN_POINTER(b3, pargs_in->int_size, int*);
    if (pargs_in->b4)
        OE_SET_IN_POINTER(b4, pargs_in->float_size, int*);
    if (pargs_in->b5)
        OE_SET_IN_POINTER(b5, pargs_in->double_size, int*);
    if (pargs_in->b6)
        OE_SET_IN_POINTER(b6, pargs_in->long_size, int*);
    if (pargs_in->b7)
        OE_SET_IN_POINTER(b7, pargs_in->size_t_size, int*);
    if (pargs_in->b8)
        OE_SET_IN_POINTER(b8, pargs_in->unsigned_size, int*);
    if (pargs_in->b9)
        OE_SET_IN_POINTER(b9, pargs_in->int8_t_size, int*);
    if (pargs_in->b10)
        OE_SET_IN_POINTER(b10, pargs_in->int16_t_size, int*);
    if (pargs_in->b11)
        OE_SET_IN_POINTER(b11, pargs_in->int32_t_size, int*);
    if (pargs_in->b12)
        OE_SET_IN_POINTER(b12, pargs_in->int64_t_size, int*);
    if (pargs_in->b13)
        OE_SET_IN_POINTER(b13, pargs_in->uint8_t_size, int*);
    if (pargs_in->b14)
        OE_SET_IN_POINTER(b14, pargs_in->uint16_t_size, int*);
    if (pargs_in->b15)
        OE_SET_IN_POINTER(b15, pargs_in->uint32_t_size, int*);
    if (pargs_in->b16)
        OE_SET_IN_POINTER(b16, pargs_in->uint64_t_size, int*);
    if (pargs_in->b17)
        OE_SET_IN_POINTER(b17, pargs_in->wchar_t_size, int*);
    if (pargs_in->b18)
        OE_SET_IN_POINTER(b18, pargs_in->long_long_size, int*);
    if (pargs_in->b19)
        OE_SET_IN_POINTER(b19, pargs_in->long_double_size, int*);
    if (pargs_in->b20)
        OE_SET_IN_POINTER(b20, pargs_in->unsigned_char_size, int*);
    if (pargs_in->b21)
        OE_SET_IN_POINTER(b21, pargs_in->unsigned_short_size, int*);
    if (pargs_in->b22)
        OE_SET_IN_POINTER(b22, pargs_in->unsigned_int_size, int*);
    if (pargs_in->b23)
        OE_SET_IN_POINTER(b23, pargs_in->unsigned_long_size, int*);
    if (pargs_in->b24)
        OE_SET_IN_POINTER(b24, pargs_in->unsigned_long_long_size, int*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_size_attribute_all_types(
        pargs_in->b1,
        pargs_in->b2,
        pargs_in->b3,
        pargs_in->b4,
        pargs_in->b5,
        pargs_in->b6,
        pargs_in->b7,
        pargs_in->b8,
        pargs_in->b9,
        pargs_in->b10,
        pargs_in->b11,
        pargs_in->b12,
        pargs_in->b13,
        pargs_in->b14,
        pargs_in->b15,
        pargs_in->b16,
        pargs_in->b17,
        pargs_in->b18,
        pargs_in->b19,
        pargs_in->b20,
        pargs_in->b21,
        pargs_in->b22,
        pargs_in->b23,
        pargs_in->b24,
        pargs_in->char_size,
        pargs_in->short_size,
        pargs_in->int_size,
        pargs_in->float_size,
        pargs_in->double_size,
        pargs_in->long_size,
        pargs_in->size_t_size,
        pargs_in->unsigned_size,
        pargs_in->int8_t_size,
        pargs_in->int16_t_size,
        pargs_in->int32_t_size,
        pargs_in->int64_t_size,
        pargs_in->uint8_t_size,
        pargs_in->uint16_t_size,
        pargs_in->uint32_t_size,
        pargs_in->uint64_t_size,
        pargs_in->wchar_t_size,
        pargs_in->long_long_size,
        pargs_in->long_double_size,
        pargs_in->unsigned_char_size,
        pargs_in->unsigned_short_size,
        pargs_in->unsigned_int_size,
        pargs_in->unsigned_long_size,
        pargs_in->unsigned_long_long_size);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_pointer_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_pointer_edl_ocalls_args_t* pargs_in = (test_pointer_edl_ocalls_args_t*)input_buffer;
    test_pointer_edl_ocalls_args_t* pargs_out = (test_pointer_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_pointer_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_pointer_assert_all_called(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_pointer_assert_all_called_args_t* pargs_in = (ecall_pointer_assert_all_called_args_t*)input_buffer;
    ecall_pointer_assert_all_called_args_t* pargs_out = (ecall_pointer_assert_all_called_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_pointer_assert_all_called(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_string_fun1(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_string_fun1_args_t* pargs_in = (ecall_string_fun1_args_t*)input_buffer;
    ecall_string_fun1_args_t* pargs_out = (ecall_string_fun1_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_POINTER(s, pargs_in->s_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR(pargs_in->s, pargs_in->s_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_string_fun1(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_string_fun2(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_string_fun2_args_t* pargs_in = (ecall_string_fun2_args_t*)input_buffer;
    ecall_string_fun2_args_t* pargs_out = (ecall_string_fun2_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_POINTER(s, pargs_in->s_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR(pargs_in->s, pargs_in->s_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_string_fun2(
        (const char*)pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_string_fun3(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_string_fun3_args_t* pargs_in = (ecall_string_fun3_args_t*)input_buffer;
    ecall_string_fun3_args_t* pargs_out = (ecall_string_fun3_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, pargs_in->s_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, pargs_in->s_len * sizeof(char), char*);

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR(pargs_in->s, pargs_in->s_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_string_fun3(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_string_fun5(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_string_fun5_args_t* pargs_in = (ecall_string_fun5_args_t*)input_buffer;
    ecall_string_fun5_args_t* pargs_out = (ecall_string_fun5_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_string_fun5(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_string_fun6(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_string_fun6_args_t* pargs_in = (ecall_string_fun6_args_t*)input_buffer;
    ecall_string_fun6_args_t* pargs_out = (ecall_string_fun6_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_string_fun6(
        (const char*)pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_string_fun7(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_string_fun7_args_t* pargs_in = (ecall_string_fun7_args_t*)input_buffer;
    ecall_string_fun7_args_t* pargs_out = (ecall_string_fun7_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s1)
        OE_SET_IN_POINTER(s1, pargs_in->s1_len * sizeof(char), char*);
    if (pargs_in->s2)
        OE_SET_IN_POINTER(s2, pargs_in->s2_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR(pargs_in->s1, pargs_in->s1_len);
    OE_CHECK_NULL_TERMINATOR(pargs_in->s2, pargs_in->s2_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_string_fun7(
        pargs_in->s1,
        pargs_in->s2);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_string_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_string_edl_ocalls_args_t* pargs_in = (test_string_edl_ocalls_args_t*)input_buffer;
    test_string_edl_ocalls_args_t* pargs_out = (test_string_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_string_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_wstring_fun1(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_wstring_fun1_args_t* pargs_in = (ecall_wstring_fun1_args_t*)input_buffer;
    ecall_wstring_fun1_args_t* pargs_out = (ecall_wstring_fun1_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_POINTER(s, pargs_in->s_len * sizeof(wchar_t), wchar_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR_WIDE(pargs_in->s, pargs_in->s_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_wstring_fun1(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_wstring_fun2(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_wstring_fun2_args_t* pargs_in = (ecall_wstring_fun2_args_t*)input_buffer;
    ecall_wstring_fun2_args_t* pargs_out = (ecall_wstring_fun2_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_POINTER(s, pargs_in->s_len * sizeof(wchar_t), wchar_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR_WIDE(pargs_in->s, pargs_in->s_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_wstring_fun2(
        (const wchar_t*)pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_wstring_fun3(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_wstring_fun3_args_t* pargs_in = (ecall_wstring_fun3_args_t*)input_buffer;
    ecall_wstring_fun3_args_t* pargs_out = (ecall_wstring_fun3_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s)
        OE_SET_IN_OUT_POINTER(s, pargs_in->s_len * sizeof(wchar_t), wchar_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s)
        OE_COPY_AND_SET_IN_OUT_POINTER(s, pargs_in->s_len * sizeof(wchar_t), wchar_t*);

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR_WIDE(pargs_in->s, pargs_in->s_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_wstring_fun3(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_wstring_fun5(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_wstring_fun5_args_t* pargs_in = (ecall_wstring_fun5_args_t*)input_buffer;
    ecall_wstring_fun5_args_t* pargs_out = (ecall_wstring_fun5_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_wstring_fun5(
        pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_wstring_fun6(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_wstring_fun6_args_t* pargs_in = (ecall_wstring_fun6_args_t*)input_buffer;
    ecall_wstring_fun6_args_t* pargs_out = (ecall_wstring_fun6_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_wstring_fun6(
        (const wchar_t*)pargs_in->s);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_wstring_fun7(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_wstring_fun7_args_t* pargs_in = (ecall_wstring_fun7_args_t*)input_buffer;
    ecall_wstring_fun7_args_t* pargs_out = (ecall_wstring_fun7_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s1)
        OE_SET_IN_POINTER(s1, pargs_in->s1_len * sizeof(wchar_t), wchar_t*);
    if (pargs_in->s2)
        OE_SET_IN_POINTER(s2, pargs_in->s2_len * sizeof(wchar_t), wchar_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR_WIDE(pargs_in->s1, pargs_in->s1_len);
    OE_CHECK_NULL_TERMINATOR_WIDE(pargs_in->s2, pargs_in->s2_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_wstring_fun7(
        pargs_in->s1,
        pargs_in->s2);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_wstring_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_wstring_edl_ocalls_args_t* pargs_in = (test_wstring_edl_ocalls_args_t*)input_buffer;
    test_wstring_edl_ocalls_args_t* pargs_out = (test_wstring_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_wstring_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_string_no_null_terminator(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_string_no_null_terminator_args_t* pargs_in = (ecall_string_no_null_terminator_args_t*)input_buffer;
    ecall_string_no_null_terminator_args_t* pargs_out = (ecall_string_no_null_terminator_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s1)
        OE_SET_IN_POINTER(s1, pargs_in->s1_len * sizeof(char), char*);
    if (pargs_in->s2)
        OE_SET_IN_OUT_POINTER(s2, pargs_in->s2_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s2)
        OE_COPY_AND_SET_IN_OUT_POINTER(s2, pargs_in->s2_len * sizeof(char), char*);

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR(pargs_in->s1, pargs_in->s1_len);
    OE_CHECK_NULL_TERMINATOR(pargs_in->s2, pargs_in->s2_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_string_no_null_terminator(
        pargs_in->s1,
        pargs_in->s2);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_wstring_no_null_terminator(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_wstring_no_null_terminator_args_t* pargs_in = (ecall_wstring_no_null_terminator_args_t*)input_buffer;
    ecall_wstring_no_null_terminator_args_t* pargs_out = (ecall_wstring_no_null_terminator_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->s1)
        OE_SET_IN_POINTER(s1, pargs_in->s1_len * sizeof(wchar_t), wchar_t*);
    if (pargs_in->s2)
        OE_SET_IN_OUT_POINTER(s2, pargs_in->s2_len * sizeof(wchar_t), wchar_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->s2)
        OE_COPY_AND_SET_IN_OUT_POINTER(s2, pargs_in->s2_len * sizeof(wchar_t), wchar_t*);

    /* Check that in/in-out strings are null terminated. */
    OE_CHECK_NULL_TERMINATOR_WIDE(pargs_in->s1, pargs_in->s1_len);
    OE_CHECK_NULL_TERMINATOR_WIDE(pargs_in->s2, pargs_in->s2_len);

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    ecall_wstring_no_null_terminator(
        pargs_in->s1,
        pargs_in->s2);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_struct1(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_struct1_args_t* pargs_in = (ecall_struct1_args_t*)input_buffer;
    ecall_struct1_args_t* pargs_out = (ecall_struct1_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->a2)
        OE_SET_IN_POINTER(a2, sizeof(MyStruct1[5]), MyStruct1*);
    if (pargs_in->a3)
        OE_SET_IN_OUT_POINTER(a3, sizeof(MyStruct1[5][5]), MyStruct1*);
    if (pargs_in->a5)
        OE_SET_IN_POINTER(a5, sizeof(MyStruct1), MyStruct1*);
    if (pargs_in->a6)
        OE_SET_IN_OUT_POINTER(a6, sizeof(MyStruct1), MyStruct1*);
    if (pargs_in->a8)
        OE_SET_IN_POINTER(a8, (5 * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a9)
        OE_SET_IN_OUT_POINTER(a9, (5 * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a11)
        OE_SET_IN_POINTER(a11, 40, MyStruct1*);
    if (pargs_in->a12)
        OE_SET_IN_OUT_POINTER(a12, 40, MyStruct1*);
    if (pargs_in->a14)
        OE_SET_IN_POINTER(a14, (pargs_in->count * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a15)
        OE_SET_IN_OUT_POINTER(a15, (pargs_in->count * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a17)
        OE_SET_IN_POINTER(a17, pargs_in->size, MyStruct1*);
    if (pargs_in->a18)
        OE_SET_IN_OUT_POINTER(a18, pargs_in->size, MyStruct1*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->a3)
        OE_COPY_AND_SET_IN_OUT_POINTER(a3, sizeof(MyStruct1[5][5]), MyStruct1*);
    if (pargs_in->a4)
        OE_SET_OUT_POINTER(a4, sizeof(MyStruct1[1][1][1]), MyStruct1*);
    if (pargs_in->a6)
        OE_COPY_AND_SET_IN_OUT_POINTER(a6, sizeof(MyStruct1), MyStruct1*);
    if (pargs_in->a7)
        OE_SET_OUT_POINTER(a7, sizeof(MyStruct1), MyStruct1*);
    if (pargs_in->a9)
        OE_COPY_AND_SET_IN_OUT_POINTER(a9, (5 * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a10)
        OE_SET_OUT_POINTER(a10, (5 * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a12)
        OE_COPY_AND_SET_IN_OUT_POINTER(a12, 40, MyStruct1*);
    if (pargs_in->a13)
        OE_SET_OUT_POINTER(a13, 40, MyStruct1*);
    if (pargs_in->a15)
        OE_COPY_AND_SET_IN_OUT_POINTER(a15, (pargs_in->count * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a16)
        OE_SET_OUT_POINTER(a16, (pargs_in->count * sizeof(MyStruct1)), MyStruct1*);
    if (pargs_in->a18)
        OE_COPY_AND_SET_IN_OUT_POINTER(a18, pargs_in->size, MyStruct1*);
    if (pargs_in->a19)
        OE_SET_OUT_POINTER(a19, pargs_in->size, MyStruct1*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_struct1(
        pargs_in->a1,
        *(MyStruct1(*)[5])pargs_in->a2,
        *(MyStruct1(*)[5][5])pargs_in->a3,
        *(MyStruct1(*)[1][1][1])pargs_in->a4,
        pargs_in->a5,
        pargs_in->a6,
        pargs_in->a7,
        pargs_in->a8,
        pargs_in->a9,
        pargs_in->a10,
        pargs_in->a11,
        pargs_in->a12,
        pargs_in->a13,
        pargs_in->a14,
        pargs_in->a15,
        pargs_in->a16,
        pargs_in->a17,
        pargs_in->a18,
        pargs_in->a19,
        pargs_in->count,
        pargs_in->size);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_struct_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_struct_edl_ocalls_args_t* pargs_in = (test_struct_edl_ocalls_args_t*)input_buffer;
    test_struct_edl_ocalls_args_t* pargs_out = (test_struct_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_struct_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_ecall_sum(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    ecall_sum_args_t* pargs_in = (ecall_sum_args_t*)input_buffer;
    ecall_sum_args_t* pargs_out = (ecall_sum_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = ecall_sum(
        pargs_in->a,
        pargs_in->b);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_switchless_ecall_sum(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    switchless_ecall_sum_args_t* pargs_in = (switchless_ecall_sum_args_t*)input_buffer;
    switchless_ecall_sum_args_t* pargs_out = (switchless_ecall_sum_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    pargs_out->_retval = switchless_ecall_sum(
        pargs_in->a,
        pargs_in->b);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_test_switchless_edl_ocalls(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    test_switchless_edl_ocalls_args_t* pargs_in = (test_switchless_edl_ocalls_args_t*)input_buffer;
    test_switchless_edl_ocalls_args_t* pargs_out = (test_switchless_edl_ocalls_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    test_switchless_edl_ocalls(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

void ecall_enc_foo1(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    enc_foo1_args_t* pargs_in = (enc_foo1_args_t*)input_buffer;
    enc_foo1_args_t* pargs_out = (enc_foo1_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    enc_foo1(
    );

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

/**** ECALL function table. ****/

oe_ecall_func_t __oe_ecalls_table[] = {
    (oe_ecall_func_t) ecall_configure,
    (oe_ecall_func_t) ecall_aliasing_a,
    (oe_ecall_func_t) ecall_aliasing_b,
    (oe_ecall_func_t) ecall_aliasing_c,
    (oe_ecall_func_t) ecall_ecall_array_char,
    (oe_ecall_func_t) ecall_ecall_array_wchar_t,
    (oe_ecall_func_t) ecall_ecall_array_short,
    (oe_ecall_func_t) ecall_ecall_array_int,
    (oe_ecall_func_t) ecall_ecall_array_float,
    (oe_ecall_func_t) ecall_ecall_array_double,
    (oe_ecall_func_t) ecall_ecall_array_long,
    (oe_ecall_func_t) ecall_ecall_array_size_t,
    (oe_ecall_func_t) ecall_ecall_array_unsigned,
    (oe_ecall_func_t) ecall_ecall_array_int8_t,
    (oe_ecall_func_t) ecall_ecall_array_int16_t,
    (oe_ecall_func_t) ecall_ecall_array_int32_t,
    (oe_ecall_func_t) ecall_ecall_array_int64_t,
    (oe_ecall_func_t) ecall_ecall_array_uint8_t,
    (oe_ecall_func_t) ecall_ecall_array_uint16_t,
    (oe_ecall_func_t) ecall_ecall_array_uint32_t,
    (oe_ecall_func_t) ecall_ecall_array_uint64_t,
    (oe_ecall_func_t) ecall_ecall_array_long_long,
    (oe_ecall_func_t) ecall_ecall_array_long_double,
    (oe_ecall_func_t) ecall_ecall_array_unsigned_char,
    (oe_ecall_func_t) ecall_ecall_array_unsigned_short,
    (oe_ecall_func_t) ecall_ecall_array_unsigned_int,
    (oe_ecall_func_t) ecall_ecall_array_unsigned_long,
    (oe_ecall_func_t) ecall_ecall_array_unsigned_long_long,
    (oe_ecall_func_t) ecall_test_array_edl_ocalls,
    (oe_ecall_func_t) ecall_ecall_array_assert_all_called,
    (oe_ecall_func_t) ecall_ecall_basic_types,
    (oe_ecall_func_t) ecall_ecall_basic_non_portable_types,
    (oe_ecall_func_t) ecall_get_enclave_sizeof,
    (oe_ecall_func_t) ecall_ecall_ret_char,
    (oe_ecall_func_t) ecall_ecall_ret_wchar_t,
    (oe_ecall_func_t) ecall_ecall_ret_short,
    (oe_ecall_func_t) ecall_ecall_ret_int,
    (oe_ecall_func_t) ecall_ecall_ret_float,
    (oe_ecall_func_t) ecall_ecall_ret_double,
    (oe_ecall_func_t) ecall_ecall_ret_long,
    (oe_ecall_func_t) ecall_ecall_ret_size_t,
    (oe_ecall_func_t) ecall_ecall_ret_unsigned,
    (oe_ecall_func_t) ecall_ecall_ret_int8_t,
    (oe_ecall_func_t) ecall_ecall_ret_int16_t,
    (oe_ecall_func_t) ecall_ecall_ret_int32_t,
    (oe_ecall_func_t) ecall_ecall_ret_int64_t,
    (oe_ecall_func_t) ecall_ecall_ret_uint8_t,
    (oe_ecall_func_t) ecall_ecall_ret_uint16_t,
    (oe_ecall_func_t) ecall_ecall_ret_uint32_t,
    (oe_ecall_func_t) ecall_ecall_ret_uint64_t,
    (oe_ecall_func_t) ecall_ecall_ret_long_long,
    (oe_ecall_func_t) ecall_ecall_ret_unsigned_char,
    (oe_ecall_func_t) ecall_ecall_ret_unsigned_short,
    (oe_ecall_func_t) ecall_ecall_ret_unsigned_int,
    (oe_ecall_func_t) ecall_ecall_ret_unsigned_long,
    (oe_ecall_func_t) ecall_ecall_ret_long_double,
    (oe_ecall_func_t) ecall_ecall_ret_unsigned_long_long,
    (oe_ecall_func_t) ecall_ecall_ret_void,
    (oe_ecall_func_t) ecall_test_basic_edl_ocalls,
    (oe_ecall_func_t) ecall_deepcopy_value,
    (oe_ecall_func_t) ecall_deepcopy_shallow,
    (oe_ecall_func_t) ecall_deepcopy_count,
    (oe_ecall_func_t) ecall_deepcopy_countparam,
    (oe_ecall_func_t) ecall_deepcopy_sizeparam,
    (oe_ecall_func_t) ecall_deepcopy_countsizeparam,
    (oe_ecall_func_t) ecall_deepcopy_countsizeparam_size,
    (oe_ecall_func_t) ecall_deepcopy_countsizeparam_count,
    (oe_ecall_func_t) ecall_deepcopy_countparamarray,
    (oe_ecall_func_t) ecall_deepcopy_sizeparamarray,
    (oe_ecall_func_t) ecall_deepcopy_countsizeparamarray,
    (oe_ecall_func_t) ecall_deepcopy_nested,
    (oe_ecall_func_t) ecall_deepcopy_super_nested,
    (oe_ecall_func_t) ecall_deepcopy_null,
    (oe_ecall_func_t) ecall_deepcopy_out_count,
    (oe_ecall_func_t) ecall_deepcopy_iovec,
    (oe_ecall_func_t) ecall_ecall_enum1,
    (oe_ecall_func_t) ecall_test_enum_edl_ocalls,
    (oe_ecall_func_t) ecall_test_errno_edl_ocalls,
    (oe_ecall_func_t) ecall_ecall_foreign_ptr_1,
    (oe_ecall_func_t) ecall_ecall_foreign_ptr_2,
    (oe_ecall_func_t) ecall_ecall_foreign_ptr_3,
    (oe_ecall_func_t) ecall_ecall_foreign_ptr_4,
    (oe_ecall_func_t) ecall_ecall_foreign_ptr_5,
    (oe_ecall_func_t) ecall_ecall_foreign_isptr_1,
    (oe_ecall_func_t) ecall_ecall_foreign_isptr_2,
    (oe_ecall_func_t) ecall_ecall_foreign_isptr_3,
    (oe_ecall_func_t) ecall_ecall_foreign_isptr_4,
    (oe_ecall_func_t) ecall_ecall_foreign_isptr_5,
    (oe_ecall_func_t) ecall_ecall_foreign_isary,
    (oe_ecall_func_t) ecall_ecall_foreign_value,
    (oe_ecall_func_t) ecall_test_foreign_edl_ocalls,
    (oe_ecall_func_t) ecall_ecall_pointer_char,
    (oe_ecall_func_t) ecall_ecall_pointer_wchar_t,
    (oe_ecall_func_t) ecall_ecall_pointer_short,
    (oe_ecall_func_t) ecall_ecall_pointer_int,
    (oe_ecall_func_t) ecall_ecall_pointer_float,
    (oe_ecall_func_t) ecall_ecall_pointer_double,
    (oe_ecall_func_t) ecall_ecall_pointer_long,
    (oe_ecall_func_t) ecall_ecall_pointer_size_t,
    (oe_ecall_func_t) ecall_ecall_pointer_unsigned,
    (oe_ecall_func_t) ecall_ecall_pointer_int8_t,
    (oe_ecall_func_t) ecall_ecall_pointer_int16_t,
    (oe_ecall_func_t) ecall_ecall_pointer_int32_t,
    (oe_ecall_func_t) ecall_ecall_pointer_int64_t,
    (oe_ecall_func_t) ecall_ecall_pointer_uint8_t,
    (oe_ecall_func_t) ecall_ecall_pointer_uint16_t,
    (oe_ecall_func_t) ecall_ecall_pointer_uint32_t,
    (oe_ecall_func_t) ecall_ecall_pointer_uint64_t,
    (oe_ecall_func_t) ecall_ecall_pointer_long_long,
    (oe_ecall_func_t) ecall_ecall_pointer_unsigned_char,
    (oe_ecall_func_t) ecall_ecall_pointer_unsigned_short,
    (oe_ecall_func_t) ecall_ecall_pointer_unsigned_int,
    (oe_ecall_func_t) ecall_ecall_pointer_unsigned_long,
    (oe_ecall_func_t) ecall_ecall_pointer_unsigned_long_long,
    (oe_ecall_func_t) ecall_ecall_pointer_long_double,
    (oe_ecall_func_t) ecall_ecall_count_attribute_all_types,
    (oe_ecall_func_t) ecall_ecall_size_attribute_all_types,
    (oe_ecall_func_t) ecall_test_pointer_edl_ocalls,
    (oe_ecall_func_t) ecall_ecall_pointer_assert_all_called,
    (oe_ecall_func_t) ecall_ecall_string_fun1,
    (oe_ecall_func_t) ecall_ecall_string_fun2,
    (oe_ecall_func_t) ecall_ecall_string_fun3,
    (oe_ecall_func_t) ecall_ecall_string_fun5,
    (oe_ecall_func_t) ecall_ecall_string_fun6,
    (oe_ecall_func_t) ecall_ecall_string_fun7,
    (oe_ecall_func_t) ecall_test_string_edl_ocalls,
    (oe_ecall_func_t) ecall_ecall_wstring_fun1,
    (oe_ecall_func_t) ecall_ecall_wstring_fun2,
    (oe_ecall_func_t) ecall_ecall_wstring_fun3,
    (oe_ecall_func_t) ecall_ecall_wstring_fun5,
    (oe_ecall_func_t) ecall_ecall_wstring_fun6,
    (oe_ecall_func_t) ecall_ecall_wstring_fun7,
    (oe_ecall_func_t) ecall_test_wstring_edl_ocalls,
    (oe_ecall_func_t) ecall_ecall_string_no_null_terminator,
    (oe_ecall_func_t) ecall_ecall_wstring_no_null_terminator,
    (oe_ecall_func_t) ecall_ecall_struct1,
    (oe_ecall_func_t) ecall_test_struct_edl_ocalls,
    (oe_ecall_func_t) ecall_ecall_sum,
    (oe_ecall_func_t) ecall_switchless_ecall_sum,
    (oe_ecall_func_t) ecall_test_switchless_edl_ocalls,
    (oe_ecall_func_t) ecall_enc_foo1
};

size_t __oe_ecalls_table_size = OE_COUNTOF(__oe_ecalls_table);

/**** OCALL function wrappers. ****/

oe_result_t ocall_array_char(
    char a1[2],
    char a2[2][2],
    char a3[3][3],
    char a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_char_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (char*)a1;
    _args.a2 = (char*)a2;
    _args.a3 = (char*)a3;
    _args.a4 = (char*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_char_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(char[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(char[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_char_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(char[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(char[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_char_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(char[2]), char*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(char[2][2]), char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_char,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_char_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(char[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(char[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_wchar_t(
    wchar_t a1[2],
    wchar_t a2[2][2],
    wchar_t a3[3][3],
    wchar_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_wchar_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (wchar_t*)a1;
    _args.a2 = (wchar_t*)a2;
    _args.a3 = (wchar_t*)a3;
    _args.a4 = (wchar_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_wchar_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(wchar_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(wchar_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_wchar_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(wchar_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(wchar_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_wchar_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(wchar_t[2]), wchar_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(wchar_t[2][2]), wchar_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_wchar_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_wchar_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(wchar_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(wchar_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_short(
    short int a1[2],
    short int a2[2][2],
    short int a3[3][3],
    short int a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_short_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (short int*)a1;
    _args.a2 = (short int*)a2;
    _args.a3 = (short int*)a3;
    _args.a4 = (short int*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_short_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(short int[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(short int[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_short_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(short int[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(short int[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_short_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(short int[2]), short int*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(short int[2][2]), short int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_short,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_short_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(short int[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(short int[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_int(
    int a1[2],
    int a2[2][2],
    int a3[3][3],
    int a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_int_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (int*)a1;
    _args.a2 = (int*)a2;
    _args.a3 = (int*)a3;
    _args.a4 = (int*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_int_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_int_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_int_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(int[2]), int*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(int[2][2]), int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_int,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_int_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(int[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(int[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_float(
    float a1[2],
    float a2[2][2],
    float a3[3][3],
    float a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_float_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (float*)a1;
    _args.a2 = (float*)a2;
    _args.a3 = (float*)a3;
    _args.a4 = (float*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_float_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(float[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(float[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_float_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(float[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(float[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_float_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(float[2]), float*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(float[2][2]), float*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_float,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_float_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(float[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(float[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_double(
    double a1[2],
    double a2[2][2],
    double a3[3][3],
    double a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_double_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (double*)a1;
    _args.a2 = (double*)a2;
    _args.a3 = (double*)a3;
    _args.a4 = (double*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_double_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(double[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(double[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_double_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(double[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(double[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_double_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(double[2]), double*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(double[2][2]), double*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_double,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_double_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(double[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(double[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_long(
    long int a1[2],
    long int a2[2][2],
    long int a3[3][3],
    long int a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (long int*)a1;
    _args.a2 = (long int*)a2;
    _args.a3 = (long int*)a3;
    _args.a4 = (long int*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_long_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long int[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long int[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_long_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long int[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long int[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(long int[2]), long int*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(long int[2][2]), long int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(long int[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(long int[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_size_t(
    size_t a1[2],
    size_t a2[2][2],
    size_t a3[3][3],
    size_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_size_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (size_t*)a1;
    _args.a2 = (size_t*)a2;
    _args.a3 = (size_t*)a3;
    _args.a4 = (size_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_size_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(size_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(size_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_size_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_size_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(size_t[2]), size_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(size_t[2][2]), size_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_size_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_size_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(size_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(size_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_unsigned(
    unsigned int a1[2],
    unsigned int a2[2][2],
    unsigned int a3[3][3],
    unsigned int a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_unsigned_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (unsigned int*)a1;
    _args.a2 = (unsigned int*)a2;
    _args.a3 = (unsigned int*)a3;
    _args.a4 = (unsigned int*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_unsigned_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_unsigned_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_unsigned_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(unsigned int[2]), unsigned int*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(unsigned int[2][2]), unsigned int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_unsigned,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_unsigned_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(unsigned int[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(unsigned int[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_int8_t(
    int8_t a1[2],
    int8_t a2[2][2],
    int8_t a3[3][3],
    int8_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_int8_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (int8_t*)a1;
    _args.a2 = (int8_t*)a2;
    _args.a3 = (int8_t*)a3;
    _args.a4 = (int8_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_int8_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int8_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int8_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_int8_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int8_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int8_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_int8_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(int8_t[2]), int8_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(int8_t[2][2]), int8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_int8_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_int8_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(int8_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(int8_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_int16_t(
    int16_t a1[2],
    int16_t a2[2][2],
    int16_t a3[3][3],
    int16_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_int16_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (int16_t*)a1;
    _args.a2 = (int16_t*)a2;
    _args.a3 = (int16_t*)a3;
    _args.a4 = (int16_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_int16_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int16_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int16_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_int16_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int16_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int16_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_int16_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(int16_t[2]), int16_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(int16_t[2][2]), int16_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_int16_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_int16_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(int16_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(int16_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_int32_t(
    int32_t a1[2],
    int32_t a2[2][2],
    int32_t a3[3][3],
    int32_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_int32_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (int32_t*)a1;
    _args.a2 = (int32_t*)a2;
    _args.a3 = (int32_t*)a3;
    _args.a4 = (int32_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_int32_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int32_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int32_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_int32_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int32_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int32_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_int32_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(int32_t[2]), int32_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(int32_t[2][2]), int32_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_int32_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_int32_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(int32_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(int32_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_int64_t(
    int64_t a1[2],
    int64_t a2[2][2],
    int64_t a3[3][3],
    int64_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_int64_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (int64_t*)a1;
    _args.a2 = (int64_t*)a2;
    _args.a3 = (int64_t*)a3;
    _args.a4 = (int64_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_int64_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int64_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int64_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_int64_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int64_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int64_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_int64_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(int64_t[2]), int64_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(int64_t[2][2]), int64_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_int64_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_int64_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(int64_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(int64_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_uint8_t(
    uint8_t a1[2],
    uint8_t a2[2][2],
    uint8_t a3[3][3],
    uint8_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_uint8_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (uint8_t*)a1;
    _args.a2 = (uint8_t*)a2;
    _args.a3 = (uint8_t*)a3;
    _args.a4 = (uint8_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_uint8_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint8_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint8_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_uint8_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_uint8_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(uint8_t[2]), uint8_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(uint8_t[2][2]), uint8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_uint8_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_uint8_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(uint8_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(uint8_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_uint16_t(
    uint16_t a1[2],
    uint16_t a2[2][2],
    uint16_t a3[3][3],
    uint16_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_uint16_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (uint16_t*)a1;
    _args.a2 = (uint16_t*)a2;
    _args.a3 = (uint16_t*)a3;
    _args.a4 = (uint16_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_uint16_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint16_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint16_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_uint16_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint16_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint16_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_uint16_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(uint16_t[2]), uint16_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(uint16_t[2][2]), uint16_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_uint16_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_uint16_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(uint16_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(uint16_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_uint32_t(
    uint32_t a1[2],
    uint32_t a2[2][2],
    uint32_t a3[3][3],
    uint32_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_uint32_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (uint32_t*)a1;
    _args.a2 = (uint32_t*)a2;
    _args.a3 = (uint32_t*)a3;
    _args.a4 = (uint32_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_uint32_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint32_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint32_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_uint32_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint32_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint32_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_uint32_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(uint32_t[2]), uint32_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(uint32_t[2][2]), uint32_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_uint32_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_uint32_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(uint32_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(uint32_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_uint64_t(
    uint64_t a1[2],
    uint64_t a2[2][2],
    uint64_t a3[3][3],
    uint64_t a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_uint64_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (uint64_t*)a1;
    _args.a2 = (uint64_t*)a2;
    _args.a3 = (uint64_t*)a3;
    _args.a4 = (uint64_t*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_uint64_t_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint64_t[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint64_t[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_uint64_t_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint64_t[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint64_t[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_uint64_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(uint64_t[2]), uint64_t*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(uint64_t[2][2]), uint64_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_uint64_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_uint64_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(uint64_t[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(uint64_t[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_long_long(
    long long a1[2],
    long long a2[2][2],
    long long a3[3][3],
    long long a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_long_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (long long*)a1;
    _args.a2 = (long long*)a2;
    _args.a3 = (long long*)a3;
    _args.a4 = (long long*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_long_long_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long long[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long long[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_long_long_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long long[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long long[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_long_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(long long[2]), long long*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(long long[2][2]), long long*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_long_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_long_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(long long[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(long long[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_unsigned_char(
    unsigned char a1[2],
    unsigned char a2[2][2],
    unsigned char a3[3][3],
    unsigned char a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_unsigned_char_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (unsigned char*)a1;
    _args.a2 = (unsigned char*)a2;
    _args.a3 = (unsigned char*)a3;
    _args.a4 = (unsigned char*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_unsigned_char_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned char[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned char[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_unsigned_char_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned char[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned char[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_unsigned_char_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(unsigned char[2]), unsigned char*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(unsigned char[2][2]), unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_unsigned_char,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_unsigned_char_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(unsigned char[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(unsigned char[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_unsigned_short(
    unsigned short int a1[2],
    unsigned short int a2[2][2],
    unsigned short int a3[3][3],
    unsigned short int a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_unsigned_short_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (unsigned short int*)a1;
    _args.a2 = (unsigned short int*)a2;
    _args.a3 = (unsigned short int*)a3;
    _args.a4 = (unsigned short int*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_unsigned_short_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned short int[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned short int[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_unsigned_short_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned short int[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned short int[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_unsigned_short_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(unsigned short int[2]), unsigned short int*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(unsigned short int[2][2]), unsigned short int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_unsigned_short,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_unsigned_short_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(unsigned short int[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(unsigned short int[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_unsigned_int(
    unsigned int a1[2],
    unsigned int a2[2][2],
    unsigned int a3[3][3],
    unsigned int a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_unsigned_int_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (unsigned int*)a1;
    _args.a2 = (unsigned int*)a2;
    _args.a3 = (unsigned int*)a3;
    _args.a4 = (unsigned int*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_unsigned_int_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_unsigned_int_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_unsigned_int_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(unsigned int[2]), unsigned int*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(unsigned int[2][2]), unsigned int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_unsigned_int,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_unsigned_int_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(unsigned int[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(unsigned int[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_unsigned_long(
    unsigned long int a1[2],
    unsigned long int a2[2][2],
    unsigned long int a3[3][3],
    unsigned long int a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_unsigned_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (unsigned long int*)a1;
    _args.a2 = (unsigned long int*)a2;
    _args.a3 = (unsigned long int*)a3;
    _args.a4 = (unsigned long int*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_unsigned_long_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long int[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long int[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_unsigned_long_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long int[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long int[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_unsigned_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(unsigned long int[2]), unsigned long int*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(unsigned long int[2][2]), unsigned long int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_unsigned_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_unsigned_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(unsigned long int[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(unsigned long int[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_unsigned_long_long(
    unsigned long long a1[2],
    unsigned long long a2[2][2],
    unsigned long long a3[3][3],
    unsigned long long a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_unsigned_long_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (unsigned long long*)a1;
    _args.a2 = (unsigned long long*)a2;
    _args.a3 = (unsigned long long*)a3;
    _args.a4 = (unsigned long long*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_unsigned_long_long_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long long[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long long[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_unsigned_long_long_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long long[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long long[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_unsigned_long_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(unsigned long long[2]), unsigned long long*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(unsigned long long[2][2]), unsigned long long*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_unsigned_long_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_unsigned_long_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(unsigned long long[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(unsigned long long[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_long_double(
    long double a1[2],
    long double a2[2][2],
    long double a3[3][3],
    long double a4[4][4])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_long_double_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (long double*)a1;
    _args.a2 = (long double*)a2;
    _args.a3 = (long double*)a3;
    _args.a4 = (long double*)a4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_long_double_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long double[2]));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long double[2][2]));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_long_double_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long double[2][2]));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long double[3][3]));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_long_double_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(long double[2]), long double*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(long double[2][2]), long double*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_long_double,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_long_double_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(long double[2][2])));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(long double[3][3])));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_array_assert_all_called(
    )
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_array_assert_all_called_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_array_assert_all_called_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_array_assert_all_called_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_array_assert_all_called_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_array_assert_all_called,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_array_assert_all_called_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_basic_types(
    char arg1,
    short int arg2,
    int arg3,
    float arg4,
    double arg5,
    size_t arg6,
    unsigned int arg7,
    int8_t arg8,
    int16_t arg9,
    int32_t arg10,
    int64_t arg11,
    uint8_t arg12,
    uint16_t arg13,
    uint32_t arg14,
    uint64_t arg15,
    long long arg16,
    unsigned char arg17,
    unsigned short int arg18,
    unsigned int arg19,
    unsigned long long arg20)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_basic_types_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.arg1 = arg1;
    _args.arg2 = arg2;
    _args.arg3 = arg3;
    _args.arg4 = arg4;
    _args.arg5 = arg5;
    _args.arg6 = arg6;
    _args.arg7 = arg7;
    _args.arg8 = arg8;
    _args.arg9 = arg9;
    _args.arg10 = arg10;
    _args.arg11 = arg11;
    _args.arg12 = arg12;
    _args.arg13 = arg13;
    _args.arg14 = arg14;
    _args.arg15 = arg15;
    _args.arg16 = arg16;
    _args.arg17 = arg17;
    _args.arg18 = arg18;
    _args.arg19 = arg19;
    _args.arg20 = arg20;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_basic_types_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_basic_types_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_basic_types_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_basic_types,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_basic_types_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_basic_non_portable_types(
    wchar_t arg1,
    long int arg2,
    unsigned long int arg3,
    long double arg4)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_basic_non_portable_types_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.arg1 = arg1;
    _args.arg2 = arg2;
    _args.arg3 = arg3;
    _args.arg4 = arg4;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_basic_non_portable_types_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_basic_non_portable_types_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_basic_non_portable_types_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_basic_non_portable_types,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_basic_non_portable_types_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t get_host_sizeof(
    uint64_t* _retval,
    type_enum_t t)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    get_host_sizeof_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.t = t;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(get_host_sizeof_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(get_host_sizeof_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (get_host_sizeof_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_get_host_sizeof,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (get_host_sizeof_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_char(char* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_char_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_char_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_char_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_char_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_char,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_char_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_wchar_t(wchar_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_wchar_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_wchar_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_wchar_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_wchar_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_wchar_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_wchar_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_short(short int* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_short_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_short_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_short_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_short_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_short,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_short_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_int(int* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_int_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_int_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_int_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_int_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_int,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_int_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_float(float* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_float_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_float_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_float_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_float_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_float,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_float_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_double(double* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_double_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_double_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_double_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_double_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_double,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_double_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_long(long int* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_size_t(size_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_size_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_size_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_size_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_size_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_size_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_size_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_unsigned(unsigned int* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_unsigned_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_unsigned_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_unsigned_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_unsigned_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_unsigned,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_unsigned_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_int8_t(int8_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_int8_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_int8_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_int8_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_int8_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_int8_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_int8_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_int16_t(int16_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_int16_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_int16_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_int16_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_int16_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_int16_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_int16_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_int32_t(int32_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_int32_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_int32_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_int32_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_int32_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_int32_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_int32_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_int64_t(int64_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_int64_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_int64_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_int64_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_int64_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_int64_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_int64_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_uint8_t(uint8_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_uint8_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_uint8_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_uint8_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_uint8_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_uint8_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_uint8_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_uint16_t(uint16_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_uint16_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_uint16_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_uint16_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_uint16_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_uint16_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_uint16_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_uint32_t(uint32_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_uint32_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_uint32_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_uint32_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_uint32_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_uint32_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_uint32_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_uint64_t(uint64_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_uint64_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_uint64_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_uint64_t_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_uint64_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_uint64_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_uint64_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_long_long(long long* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_long_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_long_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_long_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_long_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_long_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_long_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_unsigned_char(unsigned char* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_unsigned_char_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_unsigned_char_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_unsigned_char_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_unsigned_char_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_unsigned_char,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_unsigned_char_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_unsigned_short(unsigned short int* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_unsigned_short_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_unsigned_short_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_unsigned_short_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_unsigned_short_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_unsigned_short,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_unsigned_short_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_unsigned_int(unsigned int* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_unsigned_int_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_unsigned_int_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_unsigned_int_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_unsigned_int_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_unsigned_int,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_unsigned_int_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_unsigned_long(unsigned long int* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_unsigned_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_unsigned_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_unsigned_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_unsigned_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_unsigned_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_unsigned_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_long_double(long double* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_long_double_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_long_double_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_long_double_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_long_double_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_long_double,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_long_double_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_unsigned_long_long(unsigned long long* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_unsigned_long_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_unsigned_long_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_unsigned_long_long_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_unsigned_long_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_unsigned_long_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_unsigned_long_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ret_void(
    )
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_ret_void_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ret_void_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ret_void_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_ret_void_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_ret_void,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_ret_void_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_enum1(
    Color* _retval,
    Color a1,
    Color a2[5],
    Color a3[5][5],
    Color a4[1][1][1],
    Color* a5,
    Color* a6,
    Color* a7,
    Color* a8,
    Color* a9,
    Color* a10,
    Color* a11,
    Color* a12,
    Color* a13,
    Color* a14,
    Color* a15,
    Color* a16,
    Color* a17,
    Color* a18,
    Color* a19,
    size_t count,
    size_t size)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_enum1_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = a1;
    _args.a2 = (Color*)a2;
    _args.a3 = (Color*)a3;
    _args.a4 = (Color*)a4;
    _args.a5 = (Color*)a5;
    _args.a6 = (Color*)a6;
    _args.a7 = (Color*)a7;
    _args.a8 = (Color*)a8;
    _args.a9 = (Color*)a9;
    _args.a10 = (Color*)a10;
    _args.a11 = (Color*)a11;
    _args.a12 = (Color*)a12;
    _args.a13 = (Color*)a13;
    _args.a14 = (Color*)a14;
    _args.a15 = (Color*)a15;
    _args.a16 = (Color*)a16;
    _args.a17 = (Color*)a17;
    _args.a18 = (Color*)a18;
    _args.a19 = (Color*)a19;
    _args.count = count;
    _args.size = size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_enum1_args_t));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(Color[5]));
    if (a3)
        OE_ADD_SIZE(_input_buffer_size, sizeof(Color[5][5]));
    if (a5)
        OE_ADD_SIZE(_input_buffer_size, sizeof(Color));
    if (a6)
        OE_ADD_SIZE(_input_buffer_size, sizeof(Color));
    if (a8)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(Color)));
    if (a9)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(Color)));
    if (a11)
        OE_ADD_SIZE(_input_buffer_size, 8);
    if (a12)
        OE_ADD_SIZE(_input_buffer_size, 8);
    if (a14)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(Color)));
    if (a15)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(Color)));
    if (a17)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    if (a18)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_enum1_args_t));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(Color[5][5]));
    if (a4)
        OE_ADD_SIZE(_output_buffer_size, sizeof(Color[1][1][1]));
    if (a6)
        OE_ADD_SIZE(_output_buffer_size, sizeof(Color));
    if (a7)
        OE_ADD_SIZE(_output_buffer_size, sizeof(Color));
    if (a9)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(Color)));
    if (a10)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(Color)));
    if (a12)
        OE_ADD_SIZE(_output_buffer_size, 8);
    if (a13)
        OE_ADD_SIZE(_output_buffer_size, 8);
    if (a15)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(Color)));
    if (a16)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(Color)));
    if (a18)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    if (a19)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_enum1_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a2)
        OE_WRITE_IN_PARAM(a2, sizeof(Color[5]), Color*);
    if (a3)
        OE_WRITE_IN_OUT_PARAM(a3, sizeof(Color[5][5]), Color*);
    if (a5)
        OE_WRITE_IN_PARAM(a5, sizeof(Color), Color*);
    if (a6)
        OE_WRITE_IN_OUT_PARAM(a6, sizeof(Color), Color*);
    if (a8)
        OE_WRITE_IN_PARAM(a8, (5 * sizeof(Color)), Color*);
    if (a9)
        OE_WRITE_IN_OUT_PARAM(a9, (5 * sizeof(Color)), Color*);
    if (a11)
        OE_WRITE_IN_PARAM(a11, 8, Color*);
    if (a12)
        OE_WRITE_IN_OUT_PARAM(a12, 8, Color*);
    if (a14)
        OE_WRITE_IN_PARAM(a14, (_args.count * sizeof(Color)), Color*);
    if (a15)
        OE_WRITE_IN_OUT_PARAM(a15, (_args.count * sizeof(Color)), Color*);
    if (a17)
        OE_WRITE_IN_PARAM(a17, _args.size, Color*);
    if (a18)
        OE_WRITE_IN_OUT_PARAM(a18, _args.size, Color*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_enum1,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_enum1_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a3, (size_t)(sizeof(Color[5][5])));
    OE_READ_OUT_PARAM(a4, (size_t)(sizeof(Color[1][1][1])));
    OE_READ_IN_OUT_PARAM(a6, (size_t)(sizeof(Color)));
    OE_READ_OUT_PARAM(a7, (size_t)(sizeof(Color)));
    OE_READ_IN_OUT_PARAM(a9, (size_t)((5 * sizeof(Color))));
    OE_READ_OUT_PARAM(a10, (size_t)((5 * sizeof(Color))));
    OE_READ_IN_OUT_PARAM(a12, (size_t)(8));
    OE_READ_OUT_PARAM(a13, (size_t)(8));
    OE_READ_IN_OUT_PARAM(a15, (size_t)((_args.count * sizeof(Color))));
    OE_READ_OUT_PARAM(a16, (size_t)((_args.count * sizeof(Color))));
    OE_READ_IN_OUT_PARAM(a18, (size_t)(_args.size));
    OE_READ_OUT_PARAM(a19, (size_t)(_args.size));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_errno(
    )
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_errno_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_errno_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_errno_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_errno_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_errno,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_errno_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    errno = _pargs_out->_ocall_errno;


    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_set_host_errno(int e)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_set_host_errno_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.e = e;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_set_host_errno_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_set_host_errno_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_set_host_errno_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_set_host_errno,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_set_host_errno_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_noop(
    )
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_noop_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_noop_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_noop_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_noop_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_noop,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_noop_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    errno = _pargs_out->_ocall_errno;


    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_ptr_1(
    my_type1* a1,
    my_type1* a2,
    my_type1* a3)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_ptr_1_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type1*)a1;
    _args.a2 = (my_type1*)a2;
    _args.a3 = (my_type1*)a3;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_ptr_1_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(my_type1));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(my_type1));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_ptr_1_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(my_type1));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(my_type1));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_ptr_1_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(my_type1), my_type1*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(my_type1), my_type1*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_ptr_1,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_ptr_1_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(my_type1)));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(my_type1)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_ptr_2(
    my_type1* a1,
    my_type1* a2,
    my_type1* a3)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_ptr_2_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type1*)a1;
    _args.a2 = (my_type1*)a2;
    _args.a3 = (my_type1*)a3;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_ptr_2_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(my_type1)));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(my_type1)));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_ptr_2_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(my_type1)));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(my_type1)));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_ptr_2_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, (5 * sizeof(my_type1)), my_type1*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, (5 * sizeof(my_type1)), my_type1*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_ptr_2,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_ptr_2_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)((5 * sizeof(my_type1))));
    OE_READ_OUT_PARAM(a3, (size_t)((5 * sizeof(my_type1))));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_ptr_3(
    my_type1* a1,
    my_type1* a2,
    my_type1* a3)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_ptr_3_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type1*)a1;
    _args.a2 = (my_type1*)a2;
    _args.a3 = (my_type1*)a3;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_ptr_3_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, 64);
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, 64);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_ptr_3_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, 64);
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, 64);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_ptr_3_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, 64, my_type1*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, 64, my_type1*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_ptr_3,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_ptr_3_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(64));
    OE_READ_OUT_PARAM(a3, (size_t)(64));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_ptr_4(
    my_type1* a1,
    my_type1* a2,
    my_type1* a3,
    size_t count)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_ptr_4_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type1*)a1;
    _args.a2 = (my_type1*)a2;
    _args.a3 = (my_type1*)a3;
    _args.count = count;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_ptr_4_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(my_type1)));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(my_type1)));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_ptr_4_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(my_type1)));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(my_type1)));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_ptr_4_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, (_args.count * sizeof(my_type1)), my_type1*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, (_args.count * sizeof(my_type1)), my_type1*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_ptr_4,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_ptr_4_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)((_args.count * sizeof(my_type1))));
    OE_READ_OUT_PARAM(a3, (size_t)((_args.count * sizeof(my_type1))));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_ptr_5(
    my_type1* a1,
    my_type1* a2,
    my_type1* a3,
    size_t size)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_ptr_5_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type1*)a1;
    _args.a2 = (my_type1*)a2;
    _args.a3 = (my_type1*)a3;
    _args.size = size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_ptr_5_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_ptr_5_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_ptr_5_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, _args.size, my_type1*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, _args.size, my_type1*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_ptr_5,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_ptr_5_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(_args.size));
    OE_READ_OUT_PARAM(a3, (size_t)(_args.size));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_isptr_1(
    my_type2 a1,
    my_type2 a2,
    my_type2 a3)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_isptr_1_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type2)a1;
    _args.a2 = (my_type2)a2;
    _args.a3 = (my_type2)a3;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_isptr_1_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(*(my_type2)0));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(*(my_type2)0));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_isptr_1_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(*(my_type2)0));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(*(my_type2)0));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_isptr_1_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(*(my_type2)0), my_type2);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(*(my_type2)0), my_type2);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_isptr_1,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_isptr_1_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(*(my_type2)0)));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(*(my_type2)0)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_isptr_2(
    my_type2 a1,
    my_type2 a2,
    my_type2 a3)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_isptr_2_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type2)a1;
    _args.a2 = (my_type2)a2;
    _args.a3 = (my_type2)a3;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_isptr_2_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(*(my_type2)0)));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(*(my_type2)0)));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_isptr_2_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(*(my_type2)0)));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(*(my_type2)0)));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_isptr_2_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, (5 * sizeof(*(my_type2)0)), my_type2);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, (5 * sizeof(*(my_type2)0)), my_type2);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_isptr_2,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_isptr_2_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)((5 * sizeof(*(my_type2)0))));
    OE_READ_OUT_PARAM(a3, (size_t)((5 * sizeof(*(my_type2)0))));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_isptr_3(
    my_type2 a1,
    my_type2 a2,
    my_type2 a3)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_isptr_3_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type2)a1;
    _args.a2 = (my_type2)a2;
    _args.a3 = (my_type2)a3;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_isptr_3_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, 64);
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, 64);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_isptr_3_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, 64);
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, 64);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_isptr_3_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, 64, my_type2);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, 64, my_type2);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_isptr_3,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_isptr_3_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(64));
    OE_READ_OUT_PARAM(a3, (size_t)(64));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_isptr_4(
    my_type2 a1,
    my_type2 a2,
    my_type2 a3,
    size_t count)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_isptr_4_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type2)a1;
    _args.a2 = (my_type2)a2;
    _args.a3 = (my_type2)a3;
    _args.count = count;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_isptr_4_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(*(my_type2)0)));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(*(my_type2)0)));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_isptr_4_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(*(my_type2)0)));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(*(my_type2)0)));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_isptr_4_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, (_args.count * sizeof(*(my_type2)0)), my_type2);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, (_args.count * sizeof(*(my_type2)0)), my_type2);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_isptr_4,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_isptr_4_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)((_args.count * sizeof(*(my_type2)0))));
    OE_READ_OUT_PARAM(a3, (size_t)((_args.count * sizeof(*(my_type2)0))));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_isptr_5(
    my_type2 a1,
    my_type2 a2,
    my_type2 a3,
    size_t size)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_isptr_5_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = (my_type2)a1;
    _args.a2 = (my_type2)a2;
    _args.a3 = (my_type2)a3;
    _args.size = size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_isptr_5_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_isptr_5_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_isptr_5_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, _args.size, my_type2);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, _args.size, my_type2);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_isptr_5,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_isptr_5_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(_args.size));
    OE_READ_OUT_PARAM(a3, (size_t)(_args.size));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_isary(
    my_type3 a1,
    my_type3 a2,
    my_type3 a3)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_isary_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = /* foreign array of type my_type3 */ (void*)a1;
    _args.a2 = /* foreign array of type my_type3 */ (void*)a2;
    _args.a3 = /* foreign array of type my_type3 */ (void*)a3;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_isary_args_t));
    if (a1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(my_type3));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(my_type3));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_isary_args_t));
    if (a2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(my_type3));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(my_type3));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_isary_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a1)
        OE_WRITE_IN_PARAM(a1, sizeof(my_type3), /* foreign array of type my_type3 */ void*);
    if (a2)
        OE_WRITE_IN_OUT_PARAM(a2, sizeof(my_type3), /* foreign array of type my_type3 */ void*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_isary,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_isary_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a2, (size_t)(sizeof(my_type3)));
    OE_READ_OUT_PARAM(a3, (size_t)(sizeof(my_type3)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_foreign_value(
    my_type1* _retval,
    my_type1 a1)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_foreign_value_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = a1;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_foreign_value_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_foreign_value_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_foreign_value_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_foreign_value,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_foreign_value_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_char(
    char** _retval,
    char* p1,
    char* p2,
    char* p3,
    char* p4,
    char* p5,
    char* p6,
    char* p7,
    char* p8,
    char* p9,
    char* p10,
    char* p11,
    char* p12,
    char* p13,
    char* p14,
    char* p15,
    char* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_char_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (char*)p1;
    _args.p2 = (char*)p2;
    _args.p3 = (char*)p3;
    _args.p4 = (char*)p4;
    _args.p5 = (char*)p5;
    _args.p6 = (char*)p6;
    _args.p7 = (char*)p7;
    _args.p8 = (char*)p8;
    _args.p9 = (char*)p9;
    _args.p10 = (char*)p10;
    _args.p11 = (char*)p11;
    _args.p12 = (char*)p12;
    _args.p13 = (char*)p13;
    _args.p14 = (char*)p14;
    _args.p15 = (char*)p15;
    _args.p16 = (char*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_char_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(char));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(char));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(char)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(char)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(char)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(char)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_char_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(char));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(char));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(char)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(char)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(char)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(char)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_char_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(char), char*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(char), char*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(char)), char*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(char)), char*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, char*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, char*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, char*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(char)), char*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(char)), char*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, char*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_char,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_char_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(char)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(char)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(char))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(char))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(char))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(char))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_wchar_t(
    wchar_t** _retval,
    wchar_t* p1,
    wchar_t* p2,
    wchar_t* p3,
    wchar_t* p4,
    wchar_t* p5,
    wchar_t* p6,
    wchar_t* p7,
    wchar_t* p8,
    wchar_t* p9,
    wchar_t* p10,
    wchar_t* p11,
    wchar_t* p12,
    wchar_t* p13,
    wchar_t* p14,
    wchar_t* p15,
    wchar_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_wchar_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (wchar_t*)p1;
    _args.p2 = (wchar_t*)p2;
    _args.p3 = (wchar_t*)p3;
    _args.p4 = (wchar_t*)p4;
    _args.p5 = (wchar_t*)p5;
    _args.p6 = (wchar_t*)p6;
    _args.p7 = (wchar_t*)p7;
    _args.p8 = (wchar_t*)p8;
    _args.p9 = (wchar_t*)p9;
    _args.p10 = (wchar_t*)p10;
    _args.p11 = (wchar_t*)p11;
    _args.p12 = (wchar_t*)p12;
    _args.p13 = (wchar_t*)p13;
    _args.p14 = (wchar_t*)p14;
    _args.p15 = (wchar_t*)p15;
    _args.p16 = (wchar_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_wchar_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(wchar_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(wchar_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(wchar_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(wchar_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(wchar_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(wchar_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_wchar_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(wchar_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(wchar_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(wchar_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(wchar_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(wchar_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(wchar_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_wchar_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(wchar_t), wchar_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(wchar_t), wchar_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(wchar_t)), wchar_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(wchar_t)), wchar_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, wchar_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, wchar_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, wchar_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(wchar_t)), wchar_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(wchar_t)), wchar_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, wchar_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, wchar_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_wchar_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_wchar_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(wchar_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(wchar_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(wchar_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(wchar_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(wchar_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(wchar_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_short(
    short int** _retval,
    short int* p1,
    short int* p2,
    short int* p3,
    short int* p4,
    short int* p5,
    short int* p6,
    short int* p7,
    short int* p8,
    short int* p9,
    short int* p10,
    short int* p11,
    short int* p12,
    short int* p13,
    short int* p14,
    short int* p15,
    short int* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_short_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (short int*)p1;
    _args.p2 = (short int*)p2;
    _args.p3 = (short int*)p3;
    _args.p4 = (short int*)p4;
    _args.p5 = (short int*)p5;
    _args.p6 = (short int*)p6;
    _args.p7 = (short int*)p7;
    _args.p8 = (short int*)p8;
    _args.p9 = (short int*)p9;
    _args.p10 = (short int*)p10;
    _args.p11 = (short int*)p11;
    _args.p12 = (short int*)p12;
    _args.p13 = (short int*)p13;
    _args.p14 = (short int*)p14;
    _args.p15 = (short int*)p15;
    _args.p16 = (short int*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_short_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(short int));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(short int));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(short int)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(short int)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(short int)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(short int)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_short_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(short int));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(short int));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(short int)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(short int)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(short int)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(short int)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_short_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(short int), short int*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(short int), short int*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(short int)), short int*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(short int)), short int*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, short int*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, short int*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, short int*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(short int)), short int*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(short int)), short int*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, short int*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, short int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_short,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_short_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(short int)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(short int)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(short int))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(short int))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(short int))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(short int))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_int(
    int** _retval,
    int* p1,
    int* p2,
    int* p3,
    int* p4,
    int* p5,
    int* p6,
    int* p7,
    int* p8,
    int* p9,
    int* p10,
    int* p11,
    int* p12,
    int* p13,
    int* p14,
    int* p15,
    int* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_int_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (int*)p1;
    _args.p2 = (int*)p2;
    _args.p3 = (int*)p3;
    _args.p4 = (int*)p4;
    _args.p5 = (int*)p5;
    _args.p6 = (int*)p6;
    _args.p7 = (int*)p7;
    _args.p8 = (int*)p8;
    _args.p9 = (int*)p9;
    _args.p10 = (int*)p10;
    _args.p11 = (int*)p11;
    _args.p12 = (int*)p12;
    _args.p13 = (int*)p13;
    _args.p14 = (int*)p14;
    _args.p15 = (int*)p15;
    _args.p16 = (int*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_int_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_int_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_int_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(int), int*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(int), int*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(int)), int*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(int)), int*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, int*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, int*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, int*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(int)), int*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(int)), int*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, int*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_int,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_int_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(int)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(int)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(int))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(int))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(int))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(int))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_float(
    float** _retval,
    float* p1,
    float* p2,
    float* p3,
    float* p4,
    float* p5,
    float* p6,
    float* p7,
    float* p8,
    float* p9,
    float* p10,
    float* p11,
    float* p12,
    float* p13,
    float* p14,
    float* p15,
    float* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_float_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (float*)p1;
    _args.p2 = (float*)p2;
    _args.p3 = (float*)p3;
    _args.p4 = (float*)p4;
    _args.p5 = (float*)p5;
    _args.p6 = (float*)p6;
    _args.p7 = (float*)p7;
    _args.p8 = (float*)p8;
    _args.p9 = (float*)p9;
    _args.p10 = (float*)p10;
    _args.p11 = (float*)p11;
    _args.p12 = (float*)p12;
    _args.p13 = (float*)p13;
    _args.p14 = (float*)p14;
    _args.p15 = (float*)p15;
    _args.p16 = (float*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_float_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(float));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(float));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(float)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(float)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(float)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(float)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_float_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(float));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(float));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(float)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(float)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(float)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(float)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_float_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(float), float*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(float), float*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(float)), float*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(float)), float*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, float*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, float*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, float*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(float)), float*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(float)), float*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, float*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, float*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_float,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_float_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(float)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(float)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(float))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(float))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(float))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(float))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_double(
    double** _retval,
    double* p1,
    double* p2,
    double* p3,
    double* p4,
    double* p5,
    double* p6,
    double* p7,
    double* p8,
    double* p9,
    double* p10,
    double* p11,
    double* p12,
    double* p13,
    double* p14,
    double* p15,
    double* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_double_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (double*)p1;
    _args.p2 = (double*)p2;
    _args.p3 = (double*)p3;
    _args.p4 = (double*)p4;
    _args.p5 = (double*)p5;
    _args.p6 = (double*)p6;
    _args.p7 = (double*)p7;
    _args.p8 = (double*)p8;
    _args.p9 = (double*)p9;
    _args.p10 = (double*)p10;
    _args.p11 = (double*)p11;
    _args.p12 = (double*)p12;
    _args.p13 = (double*)p13;
    _args.p14 = (double*)p14;
    _args.p15 = (double*)p15;
    _args.p16 = (double*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_double_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(double));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(double));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(double)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(double)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(double)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(double)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_double_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(double));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(double));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(double)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(double)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(double)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(double)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_double_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(double), double*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(double), double*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(double)), double*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(double)), double*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, double*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, double*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, double*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(double)), double*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(double)), double*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, double*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, double*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_double,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_double_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(double)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(double)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(double))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(double))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(double))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(double))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_long(
    long int** _retval,
    long int* p1,
    long int* p2,
    long int* p3,
    long int* p4,
    long int* p5,
    long int* p6,
    long int* p7,
    long int* p8,
    long int* p9,
    long int* p10,
    long int* p11,
    long int* p12,
    long int* p13,
    long int* p14,
    long int* p15,
    long int* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (long int*)p1;
    _args.p2 = (long int*)p2;
    _args.p3 = (long int*)p3;
    _args.p4 = (long int*)p4;
    _args.p5 = (long int*)p5;
    _args.p6 = (long int*)p6;
    _args.p7 = (long int*)p7;
    _args.p8 = (long int*)p8;
    _args.p9 = (long int*)p9;
    _args.p10 = (long int*)p10;
    _args.p11 = (long int*)p11;
    _args.p12 = (long int*)p12;
    _args.p13 = (long int*)p13;
    _args.p14 = (long int*)p14;
    _args.p15 = (long int*)p15;
    _args.p16 = (long int*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_long_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long int));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long int));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(long int)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(long int)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(long int)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(long int)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_long_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long int));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long int));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(long int)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(long int)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(long int)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(long int)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(long int), long int*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(long int), long int*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(long int)), long int*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(long int)), long int*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, long int*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, long int*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, long int*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(long int)), long int*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(long int)), long int*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, long int*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, long int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(long int)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(long int)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(long int))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(long int))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(long int))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(long int))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_size_t(
    size_t** _retval,
    size_t* p1,
    size_t* p2,
    size_t* p3,
    size_t* p4,
    size_t* p5,
    size_t* p6,
    size_t* p7,
    size_t* p8,
    size_t* p9,
    size_t* p10,
    size_t* p11,
    size_t* p12,
    size_t* p13,
    size_t* p14,
    size_t* p15,
    size_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_size_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (size_t*)p1;
    _args.p2 = (size_t*)p2;
    _args.p3 = (size_t*)p3;
    _args.p4 = (size_t*)p4;
    _args.p5 = (size_t*)p5;
    _args.p6 = (size_t*)p6;
    _args.p7 = (size_t*)p7;
    _args.p8 = (size_t*)p8;
    _args.p9 = (size_t*)p9;
    _args.p10 = (size_t*)p10;
    _args.p11 = (size_t*)p11;
    _args.p12 = (size_t*)p12;
    _args.p13 = (size_t*)p13;
    _args.p14 = (size_t*)p14;
    _args.p15 = (size_t*)p15;
    _args.p16 = (size_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_size_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(size_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(size_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(size_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(size_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(size_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(size_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_size_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(size_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(size_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(size_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(size_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_size_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(size_t), size_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(size_t), size_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(size_t)), size_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(size_t)), size_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, size_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, size_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, size_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(size_t)), size_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(size_t)), size_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, size_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, size_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_size_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_size_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(size_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(size_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(size_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(size_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(size_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(size_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_unsigned(
    unsigned int** _retval,
    unsigned int* p1,
    unsigned int* p2,
    unsigned int* p3,
    unsigned int* p4,
    unsigned int* p5,
    unsigned int* p6,
    unsigned int* p7,
    unsigned int* p8,
    unsigned int* p9,
    unsigned int* p10,
    unsigned int* p11,
    unsigned int* p12,
    unsigned int* p13,
    unsigned int* p14,
    unsigned int* p15,
    unsigned int* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_unsigned_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (unsigned int*)p1;
    _args.p2 = (unsigned int*)p2;
    _args.p3 = (unsigned int*)p3;
    _args.p4 = (unsigned int*)p4;
    _args.p5 = (unsigned int*)p5;
    _args.p6 = (unsigned int*)p6;
    _args.p7 = (unsigned int*)p7;
    _args.p8 = (unsigned int*)p8;
    _args.p9 = (unsigned int*)p9;
    _args.p10 = (unsigned int*)p10;
    _args.p11 = (unsigned int*)p11;
    _args.p12 = (unsigned int*)p12;
    _args.p13 = (unsigned int*)p13;
    _args.p14 = (unsigned int*)p14;
    _args.p15 = (unsigned int*)p15;
    _args.p16 = (unsigned int*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_unsigned_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned int)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned int)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_unsigned_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned int)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned int)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_unsigned_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(unsigned int), unsigned int*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(unsigned int), unsigned int*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(unsigned int)), unsigned int*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(unsigned int)), unsigned int*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, unsigned int*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, unsigned int*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, unsigned int*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(unsigned int)), unsigned int*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(unsigned int)), unsigned int*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, unsigned int*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, unsigned int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_unsigned,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_unsigned_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(unsigned int)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(unsigned int)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(unsigned int))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(unsigned int))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(unsigned int))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(unsigned int))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_int8_t(
    int8_t** _retval,
    int8_t* p1,
    int8_t* p2,
    int8_t* p3,
    int8_t* p4,
    int8_t* p5,
    int8_t* p6,
    int8_t* p7,
    int8_t* p8,
    int8_t* p9,
    int8_t* p10,
    int8_t* p11,
    int8_t* p12,
    int8_t* p13,
    int8_t* p14,
    int8_t* p15,
    int8_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_int8_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (int8_t*)p1;
    _args.p2 = (int8_t*)p2;
    _args.p3 = (int8_t*)p3;
    _args.p4 = (int8_t*)p4;
    _args.p5 = (int8_t*)p5;
    _args.p6 = (int8_t*)p6;
    _args.p7 = (int8_t*)p7;
    _args.p8 = (int8_t*)p8;
    _args.p9 = (int8_t*)p9;
    _args.p10 = (int8_t*)p10;
    _args.p11 = (int8_t*)p11;
    _args.p12 = (int8_t*)p12;
    _args.p13 = (int8_t*)p13;
    _args.p14 = (int8_t*)p14;
    _args.p15 = (int8_t*)p15;
    _args.p16 = (int8_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_int8_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int8_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int8_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int8_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int8_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int8_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int8_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_int8_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int8_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int8_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int8_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int8_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int8_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int8_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_int8_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(int8_t), int8_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(int8_t), int8_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(int8_t)), int8_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(int8_t)), int8_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, int8_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, int8_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, int8_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(int8_t)), int8_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(int8_t)), int8_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, int8_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, int8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_int8_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_int8_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(int8_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(int8_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(int8_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(int8_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(int8_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(int8_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_int16_t(
    int16_t** _retval,
    int16_t* p1,
    int16_t* p2,
    int16_t* p3,
    int16_t* p4,
    int16_t* p5,
    int16_t* p6,
    int16_t* p7,
    int16_t* p8,
    int16_t* p9,
    int16_t* p10,
    int16_t* p11,
    int16_t* p12,
    int16_t* p13,
    int16_t* p14,
    int16_t* p15,
    int16_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_int16_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (int16_t*)p1;
    _args.p2 = (int16_t*)p2;
    _args.p3 = (int16_t*)p3;
    _args.p4 = (int16_t*)p4;
    _args.p5 = (int16_t*)p5;
    _args.p6 = (int16_t*)p6;
    _args.p7 = (int16_t*)p7;
    _args.p8 = (int16_t*)p8;
    _args.p9 = (int16_t*)p9;
    _args.p10 = (int16_t*)p10;
    _args.p11 = (int16_t*)p11;
    _args.p12 = (int16_t*)p12;
    _args.p13 = (int16_t*)p13;
    _args.p14 = (int16_t*)p14;
    _args.p15 = (int16_t*)p15;
    _args.p16 = (int16_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_int16_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int16_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int16_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int16_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int16_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int16_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int16_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_int16_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int16_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int16_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int16_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int16_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int16_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int16_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_int16_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(int16_t), int16_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(int16_t), int16_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(int16_t)), int16_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(int16_t)), int16_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, int16_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, int16_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, int16_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(int16_t)), int16_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(int16_t)), int16_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, int16_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, int16_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_int16_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_int16_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(int16_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(int16_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(int16_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(int16_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(int16_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(int16_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_int32_t(
    int32_t** _retval,
    int32_t* p1,
    int32_t* p2,
    int32_t* p3,
    int32_t* p4,
    int32_t* p5,
    int32_t* p6,
    int32_t* p7,
    int32_t* p8,
    int32_t* p9,
    int32_t* p10,
    int32_t* p11,
    int32_t* p12,
    int32_t* p13,
    int32_t* p14,
    int32_t* p15,
    int32_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_int32_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (int32_t*)p1;
    _args.p2 = (int32_t*)p2;
    _args.p3 = (int32_t*)p3;
    _args.p4 = (int32_t*)p4;
    _args.p5 = (int32_t*)p5;
    _args.p6 = (int32_t*)p6;
    _args.p7 = (int32_t*)p7;
    _args.p8 = (int32_t*)p8;
    _args.p9 = (int32_t*)p9;
    _args.p10 = (int32_t*)p10;
    _args.p11 = (int32_t*)p11;
    _args.p12 = (int32_t*)p12;
    _args.p13 = (int32_t*)p13;
    _args.p14 = (int32_t*)p14;
    _args.p15 = (int32_t*)p15;
    _args.p16 = (int32_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_int32_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int32_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int32_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int32_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int32_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int32_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int32_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_int32_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int32_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int32_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int32_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int32_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int32_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int32_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_int32_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(int32_t), int32_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(int32_t), int32_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(int32_t)), int32_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(int32_t)), int32_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, int32_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, int32_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, int32_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(int32_t)), int32_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(int32_t)), int32_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, int32_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, int32_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_int32_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_int32_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(int32_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(int32_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(int32_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(int32_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(int32_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(int32_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_int64_t(
    int64_t** _retval,
    int64_t* p1,
    int64_t* p2,
    int64_t* p3,
    int64_t* p4,
    int64_t* p5,
    int64_t* p6,
    int64_t* p7,
    int64_t* p8,
    int64_t* p9,
    int64_t* p10,
    int64_t* p11,
    int64_t* p12,
    int64_t* p13,
    int64_t* p14,
    int64_t* p15,
    int64_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_int64_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (int64_t*)p1;
    _args.p2 = (int64_t*)p2;
    _args.p3 = (int64_t*)p3;
    _args.p4 = (int64_t*)p4;
    _args.p5 = (int64_t*)p5;
    _args.p6 = (int64_t*)p6;
    _args.p7 = (int64_t*)p7;
    _args.p8 = (int64_t*)p8;
    _args.p9 = (int64_t*)p9;
    _args.p10 = (int64_t*)p10;
    _args.p11 = (int64_t*)p11;
    _args.p12 = (int64_t*)p12;
    _args.p13 = (int64_t*)p13;
    _args.p14 = (int64_t*)p14;
    _args.p15 = (int64_t*)p15;
    _args.p16 = (int64_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_int64_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int64_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(int64_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int64_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(int64_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int64_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(int64_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_int64_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int64_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(int64_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int64_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(int64_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int64_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(int64_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_int64_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(int64_t), int64_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(int64_t), int64_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(int64_t)), int64_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(int64_t)), int64_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, int64_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, int64_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, int64_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(int64_t)), int64_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(int64_t)), int64_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, int64_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, int64_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_int64_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_int64_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(int64_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(int64_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(int64_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(int64_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(int64_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(int64_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_uint8_t(
    uint8_t** _retval,
    uint8_t* p1,
    uint8_t* p2,
    uint8_t* p3,
    uint8_t* p4,
    uint8_t* p5,
    uint8_t* p6,
    uint8_t* p7,
    uint8_t* p8,
    uint8_t* p9,
    uint8_t* p10,
    uint8_t* p11,
    uint8_t* p12,
    uint8_t* p13,
    uint8_t* p14,
    uint8_t* p15,
    uint8_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_uint8_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (uint8_t*)p1;
    _args.p2 = (uint8_t*)p2;
    _args.p3 = (uint8_t*)p3;
    _args.p4 = (uint8_t*)p4;
    _args.p5 = (uint8_t*)p5;
    _args.p6 = (uint8_t*)p6;
    _args.p7 = (uint8_t*)p7;
    _args.p8 = (uint8_t*)p8;
    _args.p9 = (uint8_t*)p9;
    _args.p10 = (uint8_t*)p10;
    _args.p11 = (uint8_t*)p11;
    _args.p12 = (uint8_t*)p12;
    _args.p13 = (uint8_t*)p13;
    _args.p14 = (uint8_t*)p14;
    _args.p15 = (uint8_t*)p15;
    _args.p16 = (uint8_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_uint8_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint8_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint8_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint8_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint8_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint8_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint8_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_uint8_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint8_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint8_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint8_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint8_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_uint8_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(uint8_t), uint8_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(uint8_t), uint8_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(uint8_t)), uint8_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(uint8_t)), uint8_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, uint8_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, uint8_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, uint8_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(uint8_t)), uint8_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(uint8_t)), uint8_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, uint8_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, uint8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_uint8_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_uint8_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(uint8_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(uint8_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(uint8_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(uint8_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(uint8_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(uint8_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_uint16_t(
    uint16_t** _retval,
    uint16_t* p1,
    uint16_t* p2,
    uint16_t* p3,
    uint16_t* p4,
    uint16_t* p5,
    uint16_t* p6,
    uint16_t* p7,
    uint16_t* p8,
    uint16_t* p9,
    uint16_t* p10,
    uint16_t* p11,
    uint16_t* p12,
    uint16_t* p13,
    uint16_t* p14,
    uint16_t* p15,
    uint16_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_uint16_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (uint16_t*)p1;
    _args.p2 = (uint16_t*)p2;
    _args.p3 = (uint16_t*)p3;
    _args.p4 = (uint16_t*)p4;
    _args.p5 = (uint16_t*)p5;
    _args.p6 = (uint16_t*)p6;
    _args.p7 = (uint16_t*)p7;
    _args.p8 = (uint16_t*)p8;
    _args.p9 = (uint16_t*)p9;
    _args.p10 = (uint16_t*)p10;
    _args.p11 = (uint16_t*)p11;
    _args.p12 = (uint16_t*)p12;
    _args.p13 = (uint16_t*)p13;
    _args.p14 = (uint16_t*)p14;
    _args.p15 = (uint16_t*)p15;
    _args.p16 = (uint16_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_uint16_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint16_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint16_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint16_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint16_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint16_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint16_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_uint16_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint16_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint16_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint16_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint16_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint16_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint16_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_uint16_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(uint16_t), uint16_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(uint16_t), uint16_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(uint16_t)), uint16_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(uint16_t)), uint16_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, uint16_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, uint16_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, uint16_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(uint16_t)), uint16_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(uint16_t)), uint16_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, uint16_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, uint16_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_uint16_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_uint16_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(uint16_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(uint16_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(uint16_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(uint16_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(uint16_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(uint16_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_uint32_t(
    uint32_t** _retval,
    uint32_t* p1,
    uint32_t* p2,
    uint32_t* p3,
    uint32_t* p4,
    uint32_t* p5,
    uint32_t* p6,
    uint32_t* p7,
    uint32_t* p8,
    uint32_t* p9,
    uint32_t* p10,
    uint32_t* p11,
    uint32_t* p12,
    uint32_t* p13,
    uint32_t* p14,
    uint32_t* p15,
    uint32_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_uint32_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (uint32_t*)p1;
    _args.p2 = (uint32_t*)p2;
    _args.p3 = (uint32_t*)p3;
    _args.p4 = (uint32_t*)p4;
    _args.p5 = (uint32_t*)p5;
    _args.p6 = (uint32_t*)p6;
    _args.p7 = (uint32_t*)p7;
    _args.p8 = (uint32_t*)p8;
    _args.p9 = (uint32_t*)p9;
    _args.p10 = (uint32_t*)p10;
    _args.p11 = (uint32_t*)p11;
    _args.p12 = (uint32_t*)p12;
    _args.p13 = (uint32_t*)p13;
    _args.p14 = (uint32_t*)p14;
    _args.p15 = (uint32_t*)p15;
    _args.p16 = (uint32_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_uint32_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint32_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint32_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint32_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint32_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint32_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint32_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_uint32_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint32_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint32_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint32_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint32_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint32_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint32_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_uint32_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(uint32_t), uint32_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(uint32_t), uint32_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(uint32_t)), uint32_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(uint32_t)), uint32_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, uint32_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, uint32_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, uint32_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(uint32_t)), uint32_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(uint32_t)), uint32_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, uint32_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, uint32_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_uint32_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_uint32_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(uint32_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(uint32_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(uint32_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(uint32_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(uint32_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(uint32_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_uint64_t(
    uint64_t** _retval,
    uint64_t* p1,
    uint64_t* p2,
    uint64_t* p3,
    uint64_t* p4,
    uint64_t* p5,
    uint64_t* p6,
    uint64_t* p7,
    uint64_t* p8,
    uint64_t* p9,
    uint64_t* p10,
    uint64_t* p11,
    uint64_t* p12,
    uint64_t* p13,
    uint64_t* p14,
    uint64_t* p15,
    uint64_t* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_uint64_t_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (uint64_t*)p1;
    _args.p2 = (uint64_t*)p2;
    _args.p3 = (uint64_t*)p3;
    _args.p4 = (uint64_t*)p4;
    _args.p5 = (uint64_t*)p5;
    _args.p6 = (uint64_t*)p6;
    _args.p7 = (uint64_t*)p7;
    _args.p8 = (uint64_t*)p8;
    _args.p9 = (uint64_t*)p9;
    _args.p10 = (uint64_t*)p10;
    _args.p11 = (uint64_t*)p11;
    _args.p12 = (uint64_t*)p12;
    _args.p13 = (uint64_t*)p13;
    _args.p14 = (uint64_t*)p14;
    _args.p15 = (uint64_t*)p15;
    _args.p16 = (uint64_t*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_uint64_t_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint64_t));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint64_t));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint64_t)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(uint64_t)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint64_t)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(uint64_t)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_uint64_t_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint64_t));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint64_t));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint64_t)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(uint64_t)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint64_t)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(uint64_t)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_uint64_t_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(uint64_t), uint64_t*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(uint64_t), uint64_t*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(uint64_t)), uint64_t*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(uint64_t)), uint64_t*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, uint64_t*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, uint64_t*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, uint64_t*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(uint64_t)), uint64_t*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(uint64_t)), uint64_t*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, uint64_t*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, uint64_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_uint64_t,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_uint64_t_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(uint64_t)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(uint64_t)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(uint64_t))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(uint64_t))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(uint64_t))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(uint64_t))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_long_long(
    long long** _retval,
    long long* p1,
    long long* p2,
    long long* p3,
    long long* p4,
    long long* p5,
    long long* p6,
    long long* p7,
    long long* p8,
    long long* p9,
    long long* p10,
    long long* p11,
    long long* p12,
    long long* p13,
    long long* p14,
    long long* p15,
    long long* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_long_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (long long*)p1;
    _args.p2 = (long long*)p2;
    _args.p3 = (long long*)p3;
    _args.p4 = (long long*)p4;
    _args.p5 = (long long*)p5;
    _args.p6 = (long long*)p6;
    _args.p7 = (long long*)p7;
    _args.p8 = (long long*)p8;
    _args.p9 = (long long*)p9;
    _args.p10 = (long long*)p10;
    _args.p11 = (long long*)p11;
    _args.p12 = (long long*)p12;
    _args.p13 = (long long*)p13;
    _args.p14 = (long long*)p14;
    _args.p15 = (long long*)p15;
    _args.p16 = (long long*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_long_long_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long long));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long long));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(long long)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(long long)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(long long)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(long long)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_long_long_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long long));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long long));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(long long)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(long long)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(long long)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(long long)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_long_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(long long), long long*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(long long), long long*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(long long)), long long*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(long long)), long long*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, long long*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, long long*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, long long*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(long long)), long long*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(long long)), long long*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, long long*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, long long*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_long_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_long_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(long long)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(long long)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(long long))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(long long))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(long long))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(long long))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_unsigned_char(
    unsigned char** _retval,
    unsigned char* p1,
    unsigned char* p2,
    unsigned char* p3,
    unsigned char* p4,
    unsigned char* p5,
    unsigned char* p6,
    unsigned char* p7,
    unsigned char* p8,
    unsigned char* p9,
    unsigned char* p10,
    unsigned char* p11,
    unsigned char* p12,
    unsigned char* p13,
    unsigned char* p14,
    unsigned char* p15,
    unsigned char* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_unsigned_char_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (unsigned char*)p1;
    _args.p2 = (unsigned char*)p2;
    _args.p3 = (unsigned char*)p3;
    _args.p4 = (unsigned char*)p4;
    _args.p5 = (unsigned char*)p5;
    _args.p6 = (unsigned char*)p6;
    _args.p7 = (unsigned char*)p7;
    _args.p8 = (unsigned char*)p8;
    _args.p9 = (unsigned char*)p9;
    _args.p10 = (unsigned char*)p10;
    _args.p11 = (unsigned char*)p11;
    _args.p12 = (unsigned char*)p12;
    _args.p13 = (unsigned char*)p13;
    _args.p14 = (unsigned char*)p14;
    _args.p15 = (unsigned char*)p15;
    _args.p16 = (unsigned char*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_unsigned_char_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned char));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned char));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned char)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned char)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned char)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned char)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_unsigned_char_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned char));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned char));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned char)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned char)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned char)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned char)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_unsigned_char_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(unsigned char), unsigned char*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(unsigned char), unsigned char*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(unsigned char)), unsigned char*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(unsigned char)), unsigned char*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, unsigned char*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, unsigned char*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, unsigned char*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(unsigned char)), unsigned char*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(unsigned char)), unsigned char*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, unsigned char*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_unsigned_char,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_unsigned_char_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(unsigned char)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(unsigned char)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(unsigned char))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(unsigned char))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(unsigned char))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(unsigned char))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_unsigned_short(
    unsigned short int** _retval,
    unsigned short int* p1,
    unsigned short int* p2,
    unsigned short int* p3,
    unsigned short int* p4,
    unsigned short int* p5,
    unsigned short int* p6,
    unsigned short int* p7,
    unsigned short int* p8,
    unsigned short int* p9,
    unsigned short int* p10,
    unsigned short int* p11,
    unsigned short int* p12,
    unsigned short int* p13,
    unsigned short int* p14,
    unsigned short int* p15,
    unsigned short int* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_unsigned_short_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (unsigned short int*)p1;
    _args.p2 = (unsigned short int*)p2;
    _args.p3 = (unsigned short int*)p3;
    _args.p4 = (unsigned short int*)p4;
    _args.p5 = (unsigned short int*)p5;
    _args.p6 = (unsigned short int*)p6;
    _args.p7 = (unsigned short int*)p7;
    _args.p8 = (unsigned short int*)p8;
    _args.p9 = (unsigned short int*)p9;
    _args.p10 = (unsigned short int*)p10;
    _args.p11 = (unsigned short int*)p11;
    _args.p12 = (unsigned short int*)p12;
    _args.p13 = (unsigned short int*)p13;
    _args.p14 = (unsigned short int*)p14;
    _args.p15 = (unsigned short int*)p15;
    _args.p16 = (unsigned short int*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_unsigned_short_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned short int));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned short int));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned short int)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned short int)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned short int)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned short int)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_unsigned_short_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned short int));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned short int));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned short int)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned short int)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned short int)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned short int)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_unsigned_short_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(unsigned short int), unsigned short int*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(unsigned short int), unsigned short int*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(unsigned short int)), unsigned short int*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(unsigned short int)), unsigned short int*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, unsigned short int*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, unsigned short int*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, unsigned short int*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(unsigned short int)), unsigned short int*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(unsigned short int)), unsigned short int*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, unsigned short int*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, unsigned short int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_unsigned_short,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_unsigned_short_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(unsigned short int)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(unsigned short int)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(unsigned short int))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(unsigned short int))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(unsigned short int))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(unsigned short int))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_unsigned_int(
    unsigned int** _retval,
    unsigned int* p1,
    unsigned int* p2,
    unsigned int* p3,
    unsigned int* p4,
    unsigned int* p5,
    unsigned int* p6,
    unsigned int* p7,
    unsigned int* p8,
    unsigned int* p9,
    unsigned int* p10,
    unsigned int* p11,
    unsigned int* p12,
    unsigned int* p13,
    unsigned int* p14,
    unsigned int* p15,
    unsigned int* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_unsigned_int_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (unsigned int*)p1;
    _args.p2 = (unsigned int*)p2;
    _args.p3 = (unsigned int*)p3;
    _args.p4 = (unsigned int*)p4;
    _args.p5 = (unsigned int*)p5;
    _args.p6 = (unsigned int*)p6;
    _args.p7 = (unsigned int*)p7;
    _args.p8 = (unsigned int*)p8;
    _args.p9 = (unsigned int*)p9;
    _args.p10 = (unsigned int*)p10;
    _args.p11 = (unsigned int*)p11;
    _args.p12 = (unsigned int*)p12;
    _args.p13 = (unsigned int*)p13;
    _args.p14 = (unsigned int*)p14;
    _args.p15 = (unsigned int*)p15;
    _args.p16 = (unsigned int*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_unsigned_int_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned int));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned int)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned int)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_unsigned_int_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned int));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned int)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned int)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned int)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_unsigned_int_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(unsigned int), unsigned int*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(unsigned int), unsigned int*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(unsigned int)), unsigned int*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(unsigned int)), unsigned int*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, unsigned int*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, unsigned int*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, unsigned int*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(unsigned int)), unsigned int*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(unsigned int)), unsigned int*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, unsigned int*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, unsigned int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_unsigned_int,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_unsigned_int_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(unsigned int)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(unsigned int)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(unsigned int))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(unsigned int))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(unsigned int))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(unsigned int))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_unsigned_long(
    unsigned long int** _retval,
    unsigned long int* p1,
    unsigned long int* p2,
    unsigned long int* p3,
    unsigned long int* p4,
    unsigned long int* p5,
    unsigned long int* p6,
    unsigned long int* p7,
    unsigned long int* p8,
    unsigned long int* p9,
    unsigned long int* p10,
    unsigned long int* p11,
    unsigned long int* p12,
    unsigned long int* p13,
    unsigned long int* p14,
    unsigned long int* p15,
    unsigned long int* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_unsigned_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (unsigned long int*)p1;
    _args.p2 = (unsigned long int*)p2;
    _args.p3 = (unsigned long int*)p3;
    _args.p4 = (unsigned long int*)p4;
    _args.p5 = (unsigned long int*)p5;
    _args.p6 = (unsigned long int*)p6;
    _args.p7 = (unsigned long int*)p7;
    _args.p8 = (unsigned long int*)p8;
    _args.p9 = (unsigned long int*)p9;
    _args.p10 = (unsigned long int*)p10;
    _args.p11 = (unsigned long int*)p11;
    _args.p12 = (unsigned long int*)p12;
    _args.p13 = (unsigned long int*)p13;
    _args.p14 = (unsigned long int*)p14;
    _args.p15 = (unsigned long int*)p15;
    _args.p16 = (unsigned long int*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_unsigned_long_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long int));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long int));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned long int)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned long int)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned long int)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned long int)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_unsigned_long_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long int));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long int));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned long int)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned long int)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned long int)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned long int)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_unsigned_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(unsigned long int), unsigned long int*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(unsigned long int), unsigned long int*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(unsigned long int)), unsigned long int*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(unsigned long int)), unsigned long int*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, unsigned long int*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, unsigned long int*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, unsigned long int*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(unsigned long int)), unsigned long int*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(unsigned long int)), unsigned long int*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, unsigned long int*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, unsigned long int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_unsigned_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_unsigned_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(unsigned long int)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(unsigned long int)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(unsigned long int))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(unsigned long int))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(unsigned long int))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(unsigned long int))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_unsigned_long_long(
    unsigned long long** _retval,
    unsigned long long* p1,
    unsigned long long* p2,
    unsigned long long* p3,
    unsigned long long* p4,
    unsigned long long* p5,
    unsigned long long* p6,
    unsigned long long* p7,
    unsigned long long* p8,
    unsigned long long* p9,
    unsigned long long* p10,
    unsigned long long* p11,
    unsigned long long* p12,
    unsigned long long* p13,
    unsigned long long* p14,
    unsigned long long* p15,
    unsigned long long* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_unsigned_long_long_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (unsigned long long*)p1;
    _args.p2 = (unsigned long long*)p2;
    _args.p3 = (unsigned long long*)p3;
    _args.p4 = (unsigned long long*)p4;
    _args.p5 = (unsigned long long*)p5;
    _args.p6 = (unsigned long long*)p6;
    _args.p7 = (unsigned long long*)p7;
    _args.p8 = (unsigned long long*)p8;
    _args.p9 = (unsigned long long*)p9;
    _args.p10 = (unsigned long long*)p10;
    _args.p11 = (unsigned long long*)p11;
    _args.p12 = (unsigned long long*)p12;
    _args.p13 = (unsigned long long*)p13;
    _args.p14 = (unsigned long long*)p14;
    _args.p15 = (unsigned long long*)p15;
    _args.p16 = (unsigned long long*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_unsigned_long_long_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long long));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(unsigned long long));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned long long)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(unsigned long long)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned long long)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(unsigned long long)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_unsigned_long_long_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long long));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(unsigned long long));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned long long)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(unsigned long long)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned long long)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(unsigned long long)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_unsigned_long_long_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(unsigned long long), unsigned long long*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(unsigned long long), unsigned long long*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(unsigned long long)), unsigned long long*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(unsigned long long)), unsigned long long*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, unsigned long long*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, unsigned long long*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, unsigned long long*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(unsigned long long)), unsigned long long*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(unsigned long long)), unsigned long long*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, unsigned long long*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, unsigned long long*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_unsigned_long_long,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_unsigned_long_long_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(unsigned long long)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(unsigned long long)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(unsigned long long))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(unsigned long long))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(unsigned long long))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(unsigned long long))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_long_double(
    long double** _retval,
    long double* p1,
    long double* p2,
    long double* p3,
    long double* p4,
    long double* p5,
    long double* p6,
    long double* p7,
    long double* p8,
    long double* p9,
    long double* p10,
    long double* p11,
    long double* p12,
    long double* p13,
    long double* p14,
    long double* p15,
    long double* p16,
    int pcount,
    int psize)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_long_double_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.p1 = (long double*)p1;
    _args.p2 = (long double*)p2;
    _args.p3 = (long double*)p3;
    _args.p4 = (long double*)p4;
    _args.p5 = (long double*)p5;
    _args.p6 = (long double*)p6;
    _args.p7 = (long double*)p7;
    _args.p8 = (long double*)p8;
    _args.p9 = (long double*)p9;
    _args.p10 = (long double*)p10;
    _args.p11 = (long double*)p11;
    _args.p12 = (long double*)p12;
    _args.p13 = (long double*)p13;
    _args.p14 = (long double*)p14;
    _args.p15 = (long double*)p15;
    _args.p16 = (long double*)p16;
    _args.pcount = pcount;
    _args.psize = psize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_long_double_args_t));
    if (p1)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long double));
    if (p2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(long double));
    if (p4)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(long double)));
    if (p5)
        OE_ADD_SIZE(_input_buffer_size, (16 * sizeof(long double)));
    if (p7)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p8)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p9)
        OE_ADD_SIZE(_input_buffer_size, 80);
    if (p11)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(long double)));
    if (p12)
        OE_ADD_SIZE(_input_buffer_size, (_args.pcount * sizeof(long double)));
    if (p14)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    if (p15)
        OE_ADD_SIZE(_input_buffer_size, _args.psize);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_long_double_args_t));
    if (p2)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long double));
    if (p3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(long double));
    if (p5)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(long double)));
    if (p6)
        OE_ADD_SIZE(_output_buffer_size, (16 * sizeof(long double)));
    if (p8)
        OE_ADD_SIZE(_output_buffer_size, 80);
    if (p12)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(long double)));
    if (p13)
        OE_ADD_SIZE(_output_buffer_size, (_args.pcount * sizeof(long double)));
    if (p15)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    if (p16)
        OE_ADD_SIZE(_output_buffer_size, _args.psize);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_long_double_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (p1)
        OE_WRITE_IN_PARAM(p1, sizeof(long double), long double*);
    if (p2)
        OE_WRITE_IN_OUT_PARAM(p2, sizeof(long double), long double*);
    if (p4)
        OE_WRITE_IN_PARAM(p4, (16 * sizeof(long double)), long double*);
    if (p5)
        OE_WRITE_IN_OUT_PARAM(p5, (16 * sizeof(long double)), long double*);
    if (p7)
        OE_WRITE_IN_PARAM(p7, 80, long double*);
    if (p8)
        OE_WRITE_IN_OUT_PARAM(p8, 80, long double*);
    if (p9)
        OE_WRITE_IN_PARAM(p9, 80, long double*);
    if (p11)
        OE_WRITE_IN_PARAM(p11, (_args.pcount * sizeof(long double)), long double*);
    if (p12)
        OE_WRITE_IN_OUT_PARAM(p12, (_args.pcount * sizeof(long double)), long double*);
    if (p14)
        OE_WRITE_IN_PARAM(p14, _args.psize, long double*);
    if (p15)
        OE_WRITE_IN_OUT_PARAM(p15, _args.psize, long double*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_long_double,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_long_double_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(p2, (size_t)(sizeof(long double)));
    OE_READ_OUT_PARAM(p3, (size_t)(sizeof(long double)));
    OE_READ_IN_OUT_PARAM(p5, (size_t)((16 * sizeof(long double))));
    OE_READ_OUT_PARAM(p6, (size_t)((16 * sizeof(long double))));
    OE_READ_IN_OUT_PARAM(p8, (size_t)(80));
    OE_READ_IN_OUT_PARAM(p12, (size_t)((_args.pcount * sizeof(long double))));
    OE_READ_OUT_PARAM(p13, (size_t)((_args.pcount * sizeof(long double))));
    OE_READ_IN_OUT_PARAM(p15, (size_t)(_args.psize));
    OE_READ_OUT_PARAM(p16, (size_t)(_args.psize));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_count_attribute_all_types(
    int* b1,
    int* b2,
    int* b3,
    int* b4,
    int* b5,
    int* b6,
    int* b7,
    int* b8,
    int* b9,
    int* b10,
    int* b11,
    int* b12,
    int* b13,
    int* b14,
    int* b15,
    int* b16,
    int* b17,
    int* b18,
    int* b19,
    int* b20,
    int* b21,
    int* b22,
    int* b23,
    int* b24,
    char char_count,
    short int short_count,
    int int_count,
    float float_count,
    double double_count,
    long int long_count,
    size_t size_t_count,
    unsigned int unsigned_count,
    int8_t int8_t_count,
    int16_t int16_t_count,
    int32_t int32_t_count,
    int64_t int64_t_count,
    uint8_t uint8_t_count,
    uint16_t uint16_t_count,
    uint32_t uint32_t_count,
    uint64_t uint64_t_count,
    wchar_t wchar_t_count,
    long long long_long_count,
    long double long_double_count,
    unsigned char unsigned_char_count,
    unsigned short int unsigned_short_count,
    unsigned int unsigned_int_count,
    unsigned long int unsigned_long_count,
    unsigned long long unsigned_long_long_count)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_count_attribute_all_types_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.b1 = (int*)b1;
    _args.b2 = (int*)b2;
    _args.b3 = (int*)b3;
    _args.b4 = (int*)b4;
    _args.b5 = (int*)b5;
    _args.b6 = (int*)b6;
    _args.b7 = (int*)b7;
    _args.b8 = (int*)b8;
    _args.b9 = (int*)b9;
    _args.b10 = (int*)b10;
    _args.b11 = (int*)b11;
    _args.b12 = (int*)b12;
    _args.b13 = (int*)b13;
    _args.b14 = (int*)b14;
    _args.b15 = (int*)b15;
    _args.b16 = (int*)b16;
    _args.b17 = (int*)b17;
    _args.b18 = (int*)b18;
    _args.b19 = (int*)b19;
    _args.b20 = (int*)b20;
    _args.b21 = (int*)b21;
    _args.b22 = (int*)b22;
    _args.b23 = (int*)b23;
    _args.b24 = (int*)b24;
    _args.char_count = char_count;
    _args.short_count = short_count;
    _args.int_count = int_count;
    _args.float_count = float_count;
    _args.double_count = double_count;
    _args.long_count = long_count;
    _args.size_t_count = size_t_count;
    _args.unsigned_count = unsigned_count;
    _args.int8_t_count = int8_t_count;
    _args.int16_t_count = int16_t_count;
    _args.int32_t_count = int32_t_count;
    _args.int64_t_count = int64_t_count;
    _args.uint8_t_count = uint8_t_count;
    _args.uint16_t_count = uint16_t_count;
    _args.uint32_t_count = uint32_t_count;
    _args.uint64_t_count = uint64_t_count;
    _args.wchar_t_count = wchar_t_count;
    _args.long_long_count = long_long_count;
    _args.long_double_count = long_double_count;
    _args.unsigned_char_count = unsigned_char_count;
    _args.unsigned_short_count = unsigned_short_count;
    _args.unsigned_int_count = unsigned_int_count;
    _args.unsigned_long_count = unsigned_long_count;
    _args.unsigned_long_long_count = unsigned_long_long_count;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_count_attribute_all_types_args_t));
    if (b1)
        OE_ADD_SIZE(_input_buffer_size, (_args.char_count * sizeof(int)));
    if (b2)
        OE_ADD_SIZE(_input_buffer_size, (_args.short_count * sizeof(int)));
    if (b3)
        OE_ADD_SIZE(_input_buffer_size, (_args.int_count * sizeof(int)));
    if (b4)
        OE_ADD_SIZE(_input_buffer_size, (_args.float_count * sizeof(int)));
    if (b5)
        OE_ADD_SIZE(_input_buffer_size, (_args.double_count * sizeof(int)));
    if (b6)
        OE_ADD_SIZE(_input_buffer_size, (_args.long_count * sizeof(int)));
    if (b7)
        OE_ADD_SIZE(_input_buffer_size, (_args.size_t_count * sizeof(int)));
    if (b8)
        OE_ADD_SIZE(_input_buffer_size, (_args.unsigned_count * sizeof(int)));
    if (b9)
        OE_ADD_SIZE(_input_buffer_size, (_args.int8_t_count * sizeof(int)));
    if (b10)
        OE_ADD_SIZE(_input_buffer_size, (_args.int16_t_count * sizeof(int)));
    if (b11)
        OE_ADD_SIZE(_input_buffer_size, (_args.int32_t_count * sizeof(int)));
    if (b12)
        OE_ADD_SIZE(_input_buffer_size, (_args.int64_t_count * sizeof(int)));
    if (b13)
        OE_ADD_SIZE(_input_buffer_size, (_args.uint8_t_count * sizeof(int)));
    if (b14)
        OE_ADD_SIZE(_input_buffer_size, (_args.uint16_t_count * sizeof(int)));
    if (b15)
        OE_ADD_SIZE(_input_buffer_size, (_args.uint32_t_count * sizeof(int)));
    if (b16)
        OE_ADD_SIZE(_input_buffer_size, (_args.uint64_t_count * sizeof(int)));
    if (b17)
        OE_ADD_SIZE(_input_buffer_size, (_args.wchar_t_count * sizeof(int)));
    if (b18)
        OE_ADD_SIZE(_input_buffer_size, (_args.long_long_count * sizeof(int)));
    if (b19)
        OE_ADD_SIZE(_input_buffer_size, (_args.long_double_count * sizeof(int)));
    if (b20)
        OE_ADD_SIZE(_input_buffer_size, (_args.unsigned_char_count * sizeof(int)));
    if (b21)
        OE_ADD_SIZE(_input_buffer_size, (_args.unsigned_short_count * sizeof(int)));
    if (b22)
        OE_ADD_SIZE(_input_buffer_size, (_args.unsigned_int_count * sizeof(int)));
    if (b23)
        OE_ADD_SIZE(_input_buffer_size, (_args.unsigned_long_count * sizeof(int)));
    if (b24)
        OE_ADD_SIZE(_input_buffer_size, (_args.unsigned_long_long_count * sizeof(int)));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_count_attribute_all_types_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_count_attribute_all_types_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (b1)
        OE_WRITE_IN_PARAM(b1, (_args.char_count * sizeof(int)), int*);
    if (b2)
        OE_WRITE_IN_PARAM(b2, (_args.short_count * sizeof(int)), int*);
    if (b3)
        OE_WRITE_IN_PARAM(b3, (_args.int_count * sizeof(int)), int*);
    if (b4)
        OE_WRITE_IN_PARAM(b4, (_args.float_count * sizeof(int)), int*);
    if (b5)
        OE_WRITE_IN_PARAM(b5, (_args.double_count * sizeof(int)), int*);
    if (b6)
        OE_WRITE_IN_PARAM(b6, (_args.long_count * sizeof(int)), int*);
    if (b7)
        OE_WRITE_IN_PARAM(b7, (_args.size_t_count * sizeof(int)), int*);
    if (b8)
        OE_WRITE_IN_PARAM(b8, (_args.unsigned_count * sizeof(int)), int*);
    if (b9)
        OE_WRITE_IN_PARAM(b9, (_args.int8_t_count * sizeof(int)), int*);
    if (b10)
        OE_WRITE_IN_PARAM(b10, (_args.int16_t_count * sizeof(int)), int*);
    if (b11)
        OE_WRITE_IN_PARAM(b11, (_args.int32_t_count * sizeof(int)), int*);
    if (b12)
        OE_WRITE_IN_PARAM(b12, (_args.int64_t_count * sizeof(int)), int*);
    if (b13)
        OE_WRITE_IN_PARAM(b13, (_args.uint8_t_count * sizeof(int)), int*);
    if (b14)
        OE_WRITE_IN_PARAM(b14, (_args.uint16_t_count * sizeof(int)), int*);
    if (b15)
        OE_WRITE_IN_PARAM(b15, (_args.uint32_t_count * sizeof(int)), int*);
    if (b16)
        OE_WRITE_IN_PARAM(b16, (_args.uint64_t_count * sizeof(int)), int*);
    if (b17)
        OE_WRITE_IN_PARAM(b17, (_args.wchar_t_count * sizeof(int)), int*);
    if (b18)
        OE_WRITE_IN_PARAM(b18, (_args.long_long_count * sizeof(int)), int*);
    if (b19)
        OE_WRITE_IN_PARAM(b19, (_args.long_double_count * sizeof(int)), int*);
    if (b20)
        OE_WRITE_IN_PARAM(b20, (_args.unsigned_char_count * sizeof(int)), int*);
    if (b21)
        OE_WRITE_IN_PARAM(b21, (_args.unsigned_short_count * sizeof(int)), int*);
    if (b22)
        OE_WRITE_IN_PARAM(b22, (_args.unsigned_int_count * sizeof(int)), int*);
    if (b23)
        OE_WRITE_IN_PARAM(b23, (_args.unsigned_long_count * sizeof(int)), int*);
    if (b24)
        OE_WRITE_IN_PARAM(b24, (_args.unsigned_long_long_count * sizeof(int)), int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_count_attribute_all_types,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_count_attribute_all_types_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_size_attribute_all_types(
    int* b1,
    int* b2,
    int* b3,
    int* b4,
    int* b5,
    int* b6,
    int* b7,
    int* b8,
    int* b9,
    int* b10,
    int* b11,
    int* b12,
    int* b13,
    int* b14,
    int* b15,
    int* b16,
    int* b17,
    int* b18,
    int* b19,
    int* b20,
    int* b21,
    int* b22,
    int* b23,
    int* b24,
    char char_size,
    short int short_size,
    int int_size,
    float float_size,
    double double_size,
    long int long_size,
    size_t size_t_size,
    unsigned int unsigned_size,
    int8_t int8_t_size,
    int16_t int16_t_size,
    int32_t int32_t_size,
    int64_t int64_t_size,
    uint8_t uint8_t_size,
    uint16_t uint16_t_size,
    uint32_t uint32_t_size,
    uint64_t uint64_t_size,
    wchar_t wchar_t_size,
    long long long_long_size,
    long double long_double_size,
    unsigned char unsigned_char_size,
    unsigned short int unsigned_short_size,
    unsigned int unsigned_int_size,
    unsigned long int unsigned_long_size,
    unsigned long long unsigned_long_long_size)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_size_attribute_all_types_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.b1 = (int*)b1;
    _args.b2 = (int*)b2;
    _args.b3 = (int*)b3;
    _args.b4 = (int*)b4;
    _args.b5 = (int*)b5;
    _args.b6 = (int*)b6;
    _args.b7 = (int*)b7;
    _args.b8 = (int*)b8;
    _args.b9 = (int*)b9;
    _args.b10 = (int*)b10;
    _args.b11 = (int*)b11;
    _args.b12 = (int*)b12;
    _args.b13 = (int*)b13;
    _args.b14 = (int*)b14;
    _args.b15 = (int*)b15;
    _args.b16 = (int*)b16;
    _args.b17 = (int*)b17;
    _args.b18 = (int*)b18;
    _args.b19 = (int*)b19;
    _args.b20 = (int*)b20;
    _args.b21 = (int*)b21;
    _args.b22 = (int*)b22;
    _args.b23 = (int*)b23;
    _args.b24 = (int*)b24;
    _args.char_size = char_size;
    _args.short_size = short_size;
    _args.int_size = int_size;
    _args.float_size = float_size;
    _args.double_size = double_size;
    _args.long_size = long_size;
    _args.size_t_size = size_t_size;
    _args.unsigned_size = unsigned_size;
    _args.int8_t_size = int8_t_size;
    _args.int16_t_size = int16_t_size;
    _args.int32_t_size = int32_t_size;
    _args.int64_t_size = int64_t_size;
    _args.uint8_t_size = uint8_t_size;
    _args.uint16_t_size = uint16_t_size;
    _args.uint32_t_size = uint32_t_size;
    _args.uint64_t_size = uint64_t_size;
    _args.wchar_t_size = wchar_t_size;
    _args.long_long_size = long_long_size;
    _args.long_double_size = long_double_size;
    _args.unsigned_char_size = unsigned_char_size;
    _args.unsigned_short_size = unsigned_short_size;
    _args.unsigned_int_size = unsigned_int_size;
    _args.unsigned_long_size = unsigned_long_size;
    _args.unsigned_long_long_size = unsigned_long_long_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_size_attribute_all_types_args_t));
    if (b1)
        OE_ADD_SIZE(_input_buffer_size, _args.char_size);
    if (b2)
        OE_ADD_SIZE(_input_buffer_size, _args.short_size);
    if (b3)
        OE_ADD_SIZE(_input_buffer_size, _args.int_size);
    if (b4)
        OE_ADD_SIZE(_input_buffer_size, _args.float_size);
    if (b5)
        OE_ADD_SIZE(_input_buffer_size, _args.double_size);
    if (b6)
        OE_ADD_SIZE(_input_buffer_size, _args.long_size);
    if (b7)
        OE_ADD_SIZE(_input_buffer_size, _args.size_t_size);
    if (b8)
        OE_ADD_SIZE(_input_buffer_size, _args.unsigned_size);
    if (b9)
        OE_ADD_SIZE(_input_buffer_size, _args.int8_t_size);
    if (b10)
        OE_ADD_SIZE(_input_buffer_size, _args.int16_t_size);
    if (b11)
        OE_ADD_SIZE(_input_buffer_size, _args.int32_t_size);
    if (b12)
        OE_ADD_SIZE(_input_buffer_size, _args.int64_t_size);
    if (b13)
        OE_ADD_SIZE(_input_buffer_size, _args.uint8_t_size);
    if (b14)
        OE_ADD_SIZE(_input_buffer_size, _args.uint16_t_size);
    if (b15)
        OE_ADD_SIZE(_input_buffer_size, _args.uint32_t_size);
    if (b16)
        OE_ADD_SIZE(_input_buffer_size, _args.uint64_t_size);
    if (b17)
        OE_ADD_SIZE(_input_buffer_size, _args.wchar_t_size);
    if (b18)
        OE_ADD_SIZE(_input_buffer_size, _args.long_long_size);
    if (b19)
        OE_ADD_SIZE(_input_buffer_size, _args.long_double_size);
    if (b20)
        OE_ADD_SIZE(_input_buffer_size, _args.unsigned_char_size);
    if (b21)
        OE_ADD_SIZE(_input_buffer_size, _args.unsigned_short_size);
    if (b22)
        OE_ADD_SIZE(_input_buffer_size, _args.unsigned_int_size);
    if (b23)
        OE_ADD_SIZE(_input_buffer_size, _args.unsigned_long_size);
    if (b24)
        OE_ADD_SIZE(_input_buffer_size, _args.unsigned_long_long_size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_size_attribute_all_types_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_size_attribute_all_types_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (b1)
        OE_WRITE_IN_PARAM(b1, _args.char_size, int*);
    if (b2)
        OE_WRITE_IN_PARAM(b2, _args.short_size, int*);
    if (b3)
        OE_WRITE_IN_PARAM(b3, _args.int_size, int*);
    if (b4)
        OE_WRITE_IN_PARAM(b4, _args.float_size, int*);
    if (b5)
        OE_WRITE_IN_PARAM(b5, _args.double_size, int*);
    if (b6)
        OE_WRITE_IN_PARAM(b6, _args.long_size, int*);
    if (b7)
        OE_WRITE_IN_PARAM(b7, _args.size_t_size, int*);
    if (b8)
        OE_WRITE_IN_PARAM(b8, _args.unsigned_size, int*);
    if (b9)
        OE_WRITE_IN_PARAM(b9, _args.int8_t_size, int*);
    if (b10)
        OE_WRITE_IN_PARAM(b10, _args.int16_t_size, int*);
    if (b11)
        OE_WRITE_IN_PARAM(b11, _args.int32_t_size, int*);
    if (b12)
        OE_WRITE_IN_PARAM(b12, _args.int64_t_size, int*);
    if (b13)
        OE_WRITE_IN_PARAM(b13, _args.uint8_t_size, int*);
    if (b14)
        OE_WRITE_IN_PARAM(b14, _args.uint16_t_size, int*);
    if (b15)
        OE_WRITE_IN_PARAM(b15, _args.uint32_t_size, int*);
    if (b16)
        OE_WRITE_IN_PARAM(b16, _args.uint64_t_size, int*);
    if (b17)
        OE_WRITE_IN_PARAM(b17, _args.wchar_t_size, int*);
    if (b18)
        OE_WRITE_IN_PARAM(b18, _args.long_long_size, int*);
    if (b19)
        OE_WRITE_IN_PARAM(b19, _args.long_double_size, int*);
    if (b20)
        OE_WRITE_IN_PARAM(b20, _args.unsigned_char_size, int*);
    if (b21)
        OE_WRITE_IN_PARAM(b21, _args.unsigned_short_size, int*);
    if (b22)
        OE_WRITE_IN_PARAM(b22, _args.unsigned_int_size, int*);
    if (b23)
        OE_WRITE_IN_PARAM(b23, _args.unsigned_long_size, int*);
    if (b24)
        OE_WRITE_IN_PARAM(b24, _args.unsigned_long_long_size, int*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_size_attribute_all_types,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_size_attribute_all_types_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_pointer_assert_all_called(
    )
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_pointer_assert_all_called_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_pointer_assert_all_called_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_pointer_assert_all_called_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_pointer_assert_all_called_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_pointer_assert_all_called,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_pointer_assert_all_called_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_string_fun1(char* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_string_fun1_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (char*)s;
    _args.s_len = (s) ? (strlen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_string_fun1_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(char));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_string_fun1_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_string_fun1_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_PARAM(s, _args.s_len * sizeof(char), char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_string_fun1,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_string_fun1_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_string_fun2(const char* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_string_fun2_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (char*)s;
    _args.s_len = (s) ? (strlen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_string_fun2_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(char));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_string_fun2_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_string_fun2_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_PARAM(s, _args.s_len * sizeof(char), char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_string_fun2,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_string_fun2_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_string_fun3(char* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_string_fun3_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (char*)s;
    _args.s_len = (s) ? (strlen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_string_fun3_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(char));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_string_fun3_args_t));
    if (s)
        OE_ADD_SIZE(_output_buffer_size, _args.s_len * sizeof(char));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_string_fun3_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_OUT_PARAM(s, _args.s_len * sizeof(char), char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_string_fun3,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_string_fun3_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_CHECK_NULL_TERMINATOR(_output_buffer + _output_buffer_offset, _args.s_len);
    OE_READ_IN_OUT_PARAM(s, (size_t)(_args.s_len * sizeof(char)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_string_fun5(char* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_string_fun5_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (char*)s;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_string_fun5_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_string_fun5_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_string_fun5_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_string_fun5,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_string_fun5_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_string_fun6(const char* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_string_fun6_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (char*)s;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_string_fun6_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_string_fun6_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_string_fun6_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_string_fun6,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_string_fun6_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_string_fun7(
    char* s1,
    char* s2)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_string_fun7_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s1 = (char*)s1;
    _args.s1_len = (s1) ? (strlen(s1) + 1) : 0;
    _args.s2 = (char*)s2;
    _args.s2_len = (s2) ? (strlen(s2) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_string_fun7_args_t));
    if (s1)
        OE_ADD_SIZE(_input_buffer_size, _args.s1_len * sizeof(char));
    if (s2)
        OE_ADD_SIZE(_input_buffer_size, _args.s2_len * sizeof(char));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_string_fun7_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_string_fun7_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s1)
        OE_WRITE_IN_PARAM(s1, _args.s1_len * sizeof(char), char*);
    if (s2)
        OE_WRITE_IN_PARAM(s2, _args.s2_len * sizeof(char), char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_string_fun7,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_string_fun7_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_wstring_fun1(wchar_t* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_wstring_fun1_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (wchar_t*)s;
    _args.s_len = (s) ? (wcslen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_wstring_fun1_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(wchar_t));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_wstring_fun1_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_wstring_fun1_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_PARAM(s, _args.s_len * sizeof(wchar_t), wchar_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_wstring_fun1,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_wstring_fun1_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_wstring_fun2(const wchar_t* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_wstring_fun2_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (wchar_t*)s;
    _args.s_len = (s) ? (wcslen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_wstring_fun2_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(wchar_t));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_wstring_fun2_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_wstring_fun2_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_PARAM(s, _args.s_len * sizeof(wchar_t), wchar_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_wstring_fun2,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_wstring_fun2_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_wstring_fun3(wchar_t* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_wstring_fun3_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (wchar_t*)s;
    _args.s_len = (s) ? (wcslen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_wstring_fun3_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(wchar_t));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_wstring_fun3_args_t));
    if (s)
        OE_ADD_SIZE(_output_buffer_size, _args.s_len * sizeof(wchar_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_wstring_fun3_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_OUT_PARAM(s, _args.s_len * sizeof(wchar_t), wchar_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_wstring_fun3,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_wstring_fun3_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_CHECK_NULL_TERMINATOR_WIDE(_output_buffer + _output_buffer_offset, _args.s_len);
    OE_READ_IN_OUT_PARAM(s, (size_t)(_args.s_len * sizeof(wchar_t)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_wstring_fun5(wchar_t* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_wstring_fun5_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (wchar_t*)s;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_wstring_fun5_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_wstring_fun5_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_wstring_fun5_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_wstring_fun5,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_wstring_fun5_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_wstring_fun6(const wchar_t* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_wstring_fun6_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s = (wchar_t*)s;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_wstring_fun6_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_wstring_fun6_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_wstring_fun6_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_wstring_fun6,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_wstring_fun6_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_wstring_fun7(
    wchar_t* s1,
    wchar_t* s2)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_wstring_fun7_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.s1 = (wchar_t*)s1;
    _args.s1_len = (s1) ? (wcslen(s1) + 1) : 0;
    _args.s2 = (wchar_t*)s2;
    _args.s2_len = (s2) ? (wcslen(s2) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_wstring_fun7_args_t));
    if (s1)
        OE_ADD_SIZE(_input_buffer_size, _args.s1_len * sizeof(wchar_t));
    if (s2)
        OE_ADD_SIZE(_input_buffer_size, _args.s2_len * sizeof(wchar_t));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_wstring_fun7_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_wstring_fun7_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s1)
        OE_WRITE_IN_PARAM(s1, _args.s1_len * sizeof(wchar_t), wchar_t*);
    if (s2)
        OE_WRITE_IN_PARAM(s2, _args.s2_len * sizeof(wchar_t), wchar_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_wstring_fun7,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_wstring_fun7_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_string_no_null_terminator(
    bool erasenull,
    char* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_string_no_null_terminator_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.erasenull = erasenull;
    _args.s = (char*)s;
    _args.s_len = (s) ? (strlen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_string_no_null_terminator_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(char));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_string_no_null_terminator_args_t));
    if (s)
        OE_ADD_SIZE(_output_buffer_size, _args.s_len * sizeof(char));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_string_no_null_terminator_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_OUT_PARAM(s, _args.s_len * sizeof(char), char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_string_no_null_terminator,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_string_no_null_terminator_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_CHECK_NULL_TERMINATOR(_output_buffer + _output_buffer_offset, _args.s_len);
    OE_READ_IN_OUT_PARAM(s, (size_t)(_args.s_len * sizeof(char)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_wstring_no_null_terminator(
    bool erasenull,
    wchar_t* s)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_wstring_no_null_terminator_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.erasenull = erasenull;
    _args.s = (wchar_t*)s;
    _args.s_len = (s) ? (wcslen(s) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_wstring_no_null_terminator_args_t));
    if (s)
        OE_ADD_SIZE(_input_buffer_size, _args.s_len * sizeof(wchar_t));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_wstring_no_null_terminator_args_t));
    if (s)
        OE_ADD_SIZE(_output_buffer_size, _args.s_len * sizeof(wchar_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_wstring_no_null_terminator_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (s)
        OE_WRITE_IN_OUT_PARAM(s, _args.s_len * sizeof(wchar_t), wchar_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_wstring_no_null_terminator,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_wstring_no_null_terminator_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    OE_CHECK_NULL_TERMINATOR_WIDE(_output_buffer + _output_buffer_offset, _args.s_len);
    OE_READ_IN_OUT_PARAM(s, (size_t)(_args.s_len * sizeof(wchar_t)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_struct1(
    MyStruct1* _retval,
    MyStruct1 a1,
    MyStruct1 a2[5],
    MyStruct1 a3[5][5],
    MyStruct1 a4[1][1][1],
    MyStruct1* a5,
    MyStruct1* a6,
    MyStruct1* a7,
    MyStruct1* a8,
    MyStruct1* a9,
    MyStruct1* a10,
    MyStruct1* a11,
    MyStruct1* a12,
    MyStruct1* a13,
    MyStruct1* a14,
    MyStruct1* a15,
    MyStruct1* a16,
    MyStruct1* a17,
    MyStruct1* a18,
    MyStruct1* a19,
    size_t count,
    size_t size)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_struct1_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a1 = a1;
    _args.a2 = (MyStruct1*)a2;
    _args.a3 = (MyStruct1*)a3;
    _args.a4 = (MyStruct1*)a4;
    _args.a5 = (MyStruct1*)a5;
    _args.a6 = (MyStruct1*)a6;
    _args.a7 = (MyStruct1*)a7;
    _args.a8 = (MyStruct1*)a8;
    _args.a9 = (MyStruct1*)a9;
    _args.a10 = (MyStruct1*)a10;
    _args.a11 = (MyStruct1*)a11;
    _args.a12 = (MyStruct1*)a12;
    _args.a13 = (MyStruct1*)a13;
    _args.a14 = (MyStruct1*)a14;
    _args.a15 = (MyStruct1*)a15;
    _args.a16 = (MyStruct1*)a16;
    _args.a17 = (MyStruct1*)a17;
    _args.a18 = (MyStruct1*)a18;
    _args.a19 = (MyStruct1*)a19;
    _args.count = count;
    _args.size = size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_struct1_args_t));
    if (a2)
        OE_ADD_SIZE(_input_buffer_size, sizeof(MyStruct1[5]));
    if (a3)
        OE_ADD_SIZE(_input_buffer_size, sizeof(MyStruct1[5][5]));
    if (a5)
        OE_ADD_SIZE(_input_buffer_size, sizeof(MyStruct1));
    if (a6)
        OE_ADD_SIZE(_input_buffer_size, sizeof(MyStruct1));
    if (a8)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(MyStruct1)));
    if (a9)
        OE_ADD_SIZE(_input_buffer_size, (5 * sizeof(MyStruct1)));
    if (a11)
        OE_ADD_SIZE(_input_buffer_size, 40);
    if (a12)
        OE_ADD_SIZE(_input_buffer_size, 40);
    if (a14)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(MyStruct1)));
    if (a15)
        OE_ADD_SIZE(_input_buffer_size, (_args.count * sizeof(MyStruct1)));
    if (a17)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    if (a18)
        OE_ADD_SIZE(_input_buffer_size, _args.size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_struct1_args_t));
    if (a3)
        OE_ADD_SIZE(_output_buffer_size, sizeof(MyStruct1[5][5]));
    if (a4)
        OE_ADD_SIZE(_output_buffer_size, sizeof(MyStruct1[1][1][1]));
    if (a6)
        OE_ADD_SIZE(_output_buffer_size, sizeof(MyStruct1));
    if (a7)
        OE_ADD_SIZE(_output_buffer_size, sizeof(MyStruct1));
    if (a9)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(MyStruct1)));
    if (a10)
        OE_ADD_SIZE(_output_buffer_size, (5 * sizeof(MyStruct1)));
    if (a12)
        OE_ADD_SIZE(_output_buffer_size, 40);
    if (a13)
        OE_ADD_SIZE(_output_buffer_size, 40);
    if (a15)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(MyStruct1)));
    if (a16)
        OE_ADD_SIZE(_output_buffer_size, (_args.count * sizeof(MyStruct1)));
    if (a18)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    if (a19)
        OE_ADD_SIZE(_output_buffer_size, _args.size);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_struct1_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (a2)
        OE_WRITE_IN_PARAM(a2, sizeof(MyStruct1[5]), MyStruct1*);
    if (a3)
        OE_WRITE_IN_OUT_PARAM(a3, sizeof(MyStruct1[5][5]), MyStruct1*);
    if (a5)
        OE_WRITE_IN_PARAM(a5, sizeof(MyStruct1), MyStruct1*);
    if (a6)
        OE_WRITE_IN_OUT_PARAM(a6, sizeof(MyStruct1), MyStruct1*);
    if (a8)
        OE_WRITE_IN_PARAM(a8, (5 * sizeof(MyStruct1)), MyStruct1*);
    if (a9)
        OE_WRITE_IN_OUT_PARAM(a9, (5 * sizeof(MyStruct1)), MyStruct1*);
    if (a11)
        OE_WRITE_IN_PARAM(a11, 40, MyStruct1*);
    if (a12)
        OE_WRITE_IN_OUT_PARAM(a12, 40, MyStruct1*);
    if (a14)
        OE_WRITE_IN_PARAM(a14, (_args.count * sizeof(MyStruct1)), MyStruct1*);
    if (a15)
        OE_WRITE_IN_OUT_PARAM(a15, (_args.count * sizeof(MyStruct1)), MyStruct1*);
    if (a17)
        OE_WRITE_IN_PARAM(a17, _args.size, MyStruct1*);
    if (a18)
        OE_WRITE_IN_OUT_PARAM(a18, _args.size, MyStruct1*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_struct1,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_struct1_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_IN_OUT_PARAM(a3, (size_t)(sizeof(MyStruct1[5][5])));
    OE_READ_OUT_PARAM(a4, (size_t)(sizeof(MyStruct1[1][1][1])));
    OE_READ_IN_OUT_PARAM(a6, (size_t)(sizeof(MyStruct1)));
    OE_READ_OUT_PARAM(a7, (size_t)(sizeof(MyStruct1)));
    OE_READ_IN_OUT_PARAM(a9, (size_t)((5 * sizeof(MyStruct1))));
    OE_READ_OUT_PARAM(a10, (size_t)((5 * sizeof(MyStruct1))));
    OE_READ_IN_OUT_PARAM(a12, (size_t)(40));
    OE_READ_OUT_PARAM(a13, (size_t)(40));
    OE_READ_IN_OUT_PARAM(a15, (size_t)((_args.count * sizeof(MyStruct1))));
    OE_READ_OUT_PARAM(a16, (size_t)((_args.count * sizeof(MyStruct1))));
    OE_READ_IN_OUT_PARAM(a18, (size_t)(_args.size));
    OE_READ_OUT_PARAM(a19, (size_t)(_args.size));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_sum(
    int* _retval,
    int a,
    int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    ocall_sum_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_sum_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_sum_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (ocall_sum_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_ocall_sum,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (ocall_sum_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t switchless_ocall_sum(
    int* _retval,
    int a,
    int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    switchless_ocall_sum_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(switchless_ocall_sum_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(switchless_ocall_sum_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_switchless_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (switchless_ocall_sum_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_switchless_call_host_function(
             all_fcn_id_switchless_ocall_sum,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (switchless_ocall_sum_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_switchless_ocall_buffer(_buffer);
    return _result;
}

oe_result_t host_foo1(
    )
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    host_foo1_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* No pointers to save for deep copy. */

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(host_foo1_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(host_foo1_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (host_foo1_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             all_fcn_id_host_foo1,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (host_foo1_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

OE_EXTERNC_END
